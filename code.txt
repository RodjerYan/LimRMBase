// ===================================================================================
// Code.gs – Серверная логика (Apps Script)
// Версия: 14.1 – Исправлено "Продолжить", повышена стабильность OSM
// ===================================================================================

// --- КОНФИГУРАЦИЯ ---
const SHEET_ID = '13HkruBN9a_Y5xF8nUGpoyo3N7nJxiTW3PPgqw8FsApI';
const SHEET_NAME = 'Base';
const DASHBOARD_SHEET_NAME = 'Сводка';
const ALL_REGIONS_LIST = ["Москва","Московская область","Санкт-Петербург","Ленинградская область","Республика Адыгея","Республика Алтай","Республика Башкортостан","Республика Бурятия","Республика Дагестан","Республика Ингушетия","Кабардино-Балкарская Республика","Республика Калмыкия","Карачаево-Черкесская Республика","Республика Карелия","Республика Коми","Республика Крым","Республика Марий Эл","Республика Мордовия","Республика Саха (Якутия)","Республика Северная Осетия - Алания","Республика Татарстан","Республика Тыва","Удмуртская Республика","Республика Хакасия","Чеченская Республика","Чувашская Республика","Алтайский край","Забайкальский край","Камчатский край","Краснодарский край","Красноярский край","Пермский край","Приморский край","Ставропольский край","Хабаровский край","Амурская область","Архангельская область","Астраханская область","Белгородская область","Брянская область","Владимирская область","Волгоградская область","Вологодская область","Воронежская область","Ивановская область","Иркутская область","Калининградская область","Калужская область","Кемеровская область","Кировская область","Костромская область","Курганская область","Курская область","Липецкая область","Магаданская область","Мурманская область","Нижегородская область","Новгородская область","Новосибирская область","Омская область","Оренбургская область","Орловская область","Пензенская область","Псковская область","Ростовская область","Рязанская область","Самарская область","Саратовская область","Сахалинская область","Свердловская область","Смоленская область","Тамбовская область","Тверская область","Томская область","Тульская область","Тюменская область","Ульяновская область","Челябинская область","Ярославская область","Севастополь","Еврейская автономная область","Ненецкий автономный округ","Ханты-Мансийский автономный округ - Югра","Чукотский автономный округ","Ямало-Ненецкий автономный округ"];
const CACHE_EXPIRATION_SECONDS = 86400;
const SCRIPT_PROPERTIES = PropertiesService.getScriptProperties();
const USER_PROPERTIES = PropertiesService.getUserProperties();
const SCRIPT_CACHE = CacheService.getScriptCache();
const SCHEDULED_TRIGGER_HANDLER = 'runScheduledFullUpdate';
const OSM_CACHE_EXPIRATION = 86400;

// ===================================================================================
// === ГЛАВНЫЕ ФУНКЦИИ ИНТЕРФЕЙСА ===
// ===================================================================================

function doGet() {
  return HtmlService.createTemplateFromFile('index')
    .evaluate()
    .setTitle('Панель Управления Базой')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

function getSearchHistory() {
  return USER_PROPERTIES.getProperties();
}

// === УПРАВЛЕНИЕ ПРОЦЕССОМ ===
function startUpdateProcess(region, searchQuery) {
  if (getUpdateStatus().isUpdating) return { status: 'error', message: 'Процесс обновления уже запущен.' };
  
  USER_PROPERTIES.setProperties({ 'lastRegion': region || '', 'lastQuery': searchQuery || '' });
  
  clearProcessProperties_();
  addLogEntry_('Инициализация нового процесса...', 'info');

  const regionsToProcess = region && region.trim() ? [region.trim()] : ALL_REGIONS_LIST;
  const isFullUpdate = !(region && region.trim());
  const now = new Date().getTime().toString();

  SCRIPT_PROPERTIES.setProperties({
    'isUpdating': 'true', 'totalObjectsFoundOverall': '0',
    'regionsToProcess': JSON.stringify(regionsToProcess), 'searchQuery': searchQuery || 'ветеринарные клиники и зоомагазины',
    'startTime': now, 'isFullUpdate': isFullUpdate.toString(),
    'currentRegionIndex': '0', 'currentSettlementIndex': '0', 'settlementsForCurrentRegion': '[]',
    'totalSettlementsProcessed': '0', 'lastHeartbeat': now, 'consecutiveErrors': '0',
    'totalNew': '0', 'totalUpdated': '0', 'totalClosed': '0', 'lastSpeedCheck': now, 'citiesPerMinute': '0'
  });

  deleteProcessTriggers_();
  ScriptApp.newTrigger('mainProcessManager').timeBased().after(1000).create();
  return { status: 'success', message: 'Процесс запущен.' };
}

function continueUpdateProcess(startRegion) {
  if (getUpdateStatus().isUpdating) return { status: 'error', message: 'Процесс обновления уже запущен.' };
  const props = SCRIPT_PROPERTIES.getProperties();
  if (!props.currentRegionIndex || props.finalSummary) return { status: 'error', message: 'Нет сохраненного состояния для продолжения.' };

  const fullRegionsList = ALL_REGIONS_LIST;
  let targetRegionIndex = parseInt(props.currentRegionIndex || '0');
  let targetSettlementIndex = parseInt(props.currentSettlementIndex || '0');
  let settlements = props.settlementsForCurrentRegion || '[]';

  // Если указан новый регион для старта, переключаемся на него и сбрасываем прогресс по городам
  if (startRegion && startRegion.trim()) {
    const regionName = startRegion.trim().toLowerCase();
    let idx = fullRegionsList.findIndex(r => r.toLowerCase() === regionName); // Сначала точное совпадение
    if (idx === -1) idx = fullRegionsList.findIndex(r => r.toLowerCase().includes(regionName)); // Потом частичное

    if (idx !== -1) {
      targetRegionIndex = idx;
      targetSettlementIndex = 0; // Сброс для нового региона
      settlements = '[]';         // Сброс для нового региона
      addLogEntry_(`Продолжение с нового региона: "${fullRegionsList[idx]}"`, 'info');
    } else {
      addLogEntry_(`Регион "${startRegion}" не найден. Продолжаем с последней сохраненной точки.`, 'warning');
    }
  } else {
    addLogEntry_('Продолжение с последней сохраненной точки...', 'info');
  }

  SCRIPT_PROPERTIES.setProperties({
    'isUpdating': 'true', 'regionsToProcess': JSON.stringify(fullRegionsList),
    'currentRegionIndex': targetRegionIndex.toString(),
    'currentSettlementIndex': targetSettlementIndex.toString(),
    'settlementsForCurrentRegion': settlements,
    'consecutiveErrors': '0'
  });
  SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
  SCRIPT_PROPERTIES.setProperty('lastHeartbeat', new Date().getTime().toString());

  deleteProcessTriggers_();
  ScriptApp.newTrigger('mainProcessManager').timeBased().after(1000).create();
  return { status: 'success', message: 'Процесс возобновлён.' };
}

function cancelUpdateProcess() {
  SCRIPT_PROPERTIES.setProperty('cancelRequested', 'true');
  return { status: 'success', message: 'Запрос на остановку отправлен.' };
}

function stopAllProcesses() {
  ScriptApp.getProjectTriggers().forEach(t => ScriptApp.deleteTrigger(t));
  clearProcessProperties_();
  SCRIPT_PROPERTIES.deleteProperty('scheduleFrequency');
  addLogEntry_('Все процессы и триггеры были аварийно остановлены.', 'warning');
}

// ===================================================================================
// === МЕНЕДЖЕР ПРОЦЕССА ===
// ===================================================================================
function mainProcessManager() {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(60000)) { createContinuationTrigger_('mainProcessManager', 5000); return; }

  try {
    let props = SCRIPT_PROPERTIES.getProperties();
    if (props.isUpdating !== 'true') { deleteProcessTriggers_(); return; }
    if (props.cancelRequested === 'true') {
      addLogEntry_('Процесс остановлен пользователем.', 'warning');
      SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
      SCRIPT_PROPERTIES.setProperty('progressMessage', 'Пауза. Нажмите "Продолжить".');
      SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
      deleteProcessTriggers_();
      return;
    }

    SCRIPT_PROPERTIES.setProperty('lastHeartbeat', new Date().getTime().toString());

    const regions = JSON.parse(props.regionsToProcess);
    let regionIndex = parseInt(props.currentRegionIndex || '0');
    let settlementIndex = parseInt(props.currentSettlementIndex || '0');
    let settlements = JSON.parse(props.settlementsForCurrentRegion || '[]');

    updateSpeedStats_(props, settlementIndex);

    if (settlementIndex >= settlements.length) {
      if (regionIndex >= regions.length) {
        if (props.isFullUpdate === 'true') finalizeSmartUpdate_();
        resetState_('Обновление успешно завершено.', parseInt(props.totalSettlementsProcessed || '0'), parseInt(props.totalObjectsFoundOverall || '0'));
        return;
      }
      const currentRegion = regions[regionIndex];
      addLogEntry_(`--- Обработка нового региона: ${currentRegion} (${regionIndex + 1}/${regions.length}) ---`, 'success');

      const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
      if (props.isFullUpdate === 'true' && regionIndex === 0) prepareForSmartUpdate_(sheet, 'full', null);
      else if (props.isFullUpdate !== 'true') prepareForSmartUpdate_(sheet, detectRegionType_(currentRegion), currentRegion);

      let newSettlements = getSettlementsForRegion_(currentRegion) || [];
      if (newSettlements.length === 0) {
        addLogEntry_(`В "${currentRegion}" не найдено НП. Пропускаем.`, 'warning');
        SCRIPT_PROPERTIES.setProperty('currentRegionIndex', (regionIndex + 1).toString());
        createContinuationTrigger_('mainProcessManager', 1000);
        return;
      }

      SCRIPT_PROPERTIES.setProperties({
        'settlementsForCurrentRegion': JSON.stringify(newSettlements),
        'currentSettlementIndex': '0'
      });
      addLogEntry_(`Список НП для "${currentRegion}" получен. Начинаем обработку...`, 'info');
      updateProgressMessage_(regions, regionIndex, 0, newSettlements.length, props);
      createContinuationTrigger_('mainProcessManager', 1000);
      return;
    }

    const settlementName = settlements[settlementIndex];
    const regionName = regions[regionIndex];
    updateProgressMessage_(regions, regionIndex, settlementIndex, settlements.length, props, settlementName);

    const result = searchByOSM_(settlementName, props.searchQuery, regionName);
    
    let newCnt = 0, updCnt = 0, closedCnt = 0;
    if (result && result.status === 'success' && result.data && result.data.length > 0) {
      const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
      try {
        const stats = smartUpdateSheet_(sheet, result.data, settlementName);
        newCnt = stats.new; updCnt = stats.updated; closedCnt = stats.closed;
        addLogEntry_(`→ ${settlementName}: +${newCnt} новых, ${updCnt} обновлено, ${closedCnt} закрыто`, 'success');
      } catch (e) {
        addLogEntry_(`ОШИБКА ЗАПИСИ в "${settlementName}": ${e.message}`, 'error');
      }
    } else if (result.status === 'error'){
        addLogEntry_(`→ ${settlementName}: Ошибка поиска - ${result.message}`, 'warning');
    } else {
      addLogEntry_(`→ ${settlementName}: ничего не найдено`, 'info');
    }

    const totalNew = parseInt(props.totalNew || '0') + newCnt;
    const totalUpd = parseInt(props.totalUpdated || '0') + updCnt;
    const totalClosed = parseInt(props.totalClosed || '0') + closedCnt;
    SCRIPT_PROPERTIES.setProperties({
      'totalNew': totalNew.toString(), 'totalUpdated': totalUpd.toString(), 'totalClosed': totalClosed.toString()
    });

    SCRIPT_PROPERTIES.setProperty('currentSettlementIndex', (settlementIndex + 1).toString());
    if (settlementIndex + 1 >= settlements.length) {
      const total = parseInt(props.totalSettlementsProcessed || '0') + settlements.length;
      SCRIPT_PROPERTIES.setProperty('totalSettlementsProcessed', total.toString());
      SCRIPT_PROPERTIES.setProperty('currentRegionIndex', (regionIndex + 1).toString());
    }
    SCRIPT_PROPERTIES.setProperty('consecutiveErrors', '0');
    createContinuationTrigger_('mainProcessManager', 2000);

  } catch (e) {
    addLogEntry_(`КРИТИЧЕСКАЯ ОШИБКА: ${e.message}\n${e.stack}`, 'error');
    const errors = parseInt(SCRIPT_PROPERTIES.getProperty('consecutiveErrors') || '0') + 1;
    SCRIPT_PROPERTIES.setProperty('consecutiveErrors', errors.toString());
    if (errors >= 3) {
      try { 
        const adminEmail = SCRIPT_PROPERTIES.getProperty('ADMIN_EMAIL') || Session.getEffectiveUser().getEmail();
        GmailApp.sendEmail(adminEmail, 'Критическая ошибка в скрипте обновления базы', e.stack); 
      } catch {}
    }
    SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
    deleteProcessTriggers_();
  } finally { lock.releaseLock(); }
}

// ===================================================================================
// === ЛОГИКА ПОИСКА (ТОЛЬКО OSM) ===
// ===================================================================================
function searchByOSM_(settlementName, searchQuery, regionContext) {
  const cacheKey = `osm_revgeo_v2_${settlementName}_${searchQuery.replace(/\s/g, '_')}`;
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) {
    addLogEntry_(`OSM кэш (с адресами) для "${settlementName}" использован.`, 'info');
    return JSON.parse(cached);
  }

  addLogEntry_(`Поиск OSM для "${settlementName}"`, 'info');
  
  const overpassQuery = `
    [out:json][timeout:180];
    area[name="${settlementName}"]->.searchArea;
    (
      node["amenity"="veterinary"](area.searchArea);
      way["amenity"="veterinary"](area.searchArea);
      relation["amenity"="veterinary"](area.searchArea);
      node["shop"~"pet|pet_supply"](area.searchArea);
      way["shop"~"pet|pet_supply"](area.searchArea);
      relation["shop"~"pet|pet_supply"](area.searchArea);
    );
    out body center geom;
  `;
  
  const options = { 'method': 'post', 'payload': 'data=' + encodeURIComponent(overpassQuery), 'muteHttpExceptions': true };
  
  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      const response = UrlFetchApp.fetch('https://overpass-api.de/api/interpreter', options);
      if (response.getResponseCode() !== 200) throw new Error(`Overpass API вернул код ${response.getResponseCode()}`);
      
      const data = JSON.parse(response.getContentText());
      if (!data.elements || data.elements.length === 0) {
        return { status: 'success', data: [] };
      }
      
      const clientsData = [];
      for (const el of data.elements.slice(0, 50)) {
        const tags = el.tags || {};
        const lat = el.lat || el.center?.lat;
        const lon = el.lon || el.center?.lon;
        
        let address = tags['addr:full'] || (tags['addr:street'] ? `${tags['addr:street']}, ${tags['addr:housenumber'] || ''}` : '');
        
        if (!address && lat && lon) {
          address = getAddressFromCoords_(lat, lon, settlementName);
        }

        const isVet = tags.amenity === 'veterinary';
        const category = isVet ? 'ветеринарная клиника' : 'зоомагазин';

        clientsData.push({
          'Наименование': tags.name || `${category} #${el.id}`,
          'Адрес': address ? `${settlementName}, ${address}`.replace(/, $/, '') : settlementName,
          'Категория': category,
          'Контакты': tags.phone || tags['contact:phone'] || tags.website || 'Не указано',
          'Субъект': regionContext
        });
      }
      
      const result = { status: 'success', data: clientsData };
      SCRIPT_CACHE.put(cacheKey, JSON.stringify(result), OSM_CACHE_EXPIRATION);
      return result;

    } catch (e) {
      addLogEntry_(`OSM ошибка (попытка ${attempt}/3): ${e.message}.`, 'warning');
      if (attempt < 3) Utilities.sleep(30000);
      else {
        addLogEntry_(`OSM недоступен для "${settlementName}" после 3 попыток.`, 'error');
        return { status: 'error', message: `OSM недоступен для "${settlementName}"` };
      }
    }
  }
}

function getAddressFromCoords_(lat, lon, fallbackCity) {
  const cacheKey = `revgeo_${lat.toFixed(4)}_${lon.toFixed(4)}`;
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) return cached;
  
  try {
    Utilities.sleep(1100); // Nominatim rate limit
    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&accept-language=ru`;
    const response = UrlFetchApp.fetch(url, { 'muteHttpExceptions': true, 'headers': {'User-Agent': 'AppsScript-Client-OKB/1.0'} });
    if (response.getResponseCode() !== 200) throw new Error(`Nominatim: ${response.getResponseCode()}`);
    
    const data = JSON.parse(response.getContentText());
    const addr = data.address;
    const addressString = [addr.road, addr.house_number].filter(Boolean).join(', ');

    if (addressString) {
      SCRIPT_CACHE.put(cacheKey, addressString, 86400 * 7); // Cache for a week
      return addressString;
    }
  } catch (e) {
    addLogEntry_(`Ошибка геокодирования: ${e.message}`, 'warning');
  }
  return ''; // Return empty if fail, main function will handle fallback
}

// ===================================================================================
// === РАБОТА С ТАБЛИЦЕЙ ===
// ===================================================================================
function smartUpdateSheet_(sheet, newClients, settlementName) {
  if (!sheet || !newClients || newClients.length === 0) return {new: 0, updated: 0, closed: 0};

  const lastRow = sheet.getLastRow();
  const startRow = 2;
  const numRows = lastRow > 1 ? lastRow - 1 : 0;
  const existing = numRows > 0 ? sheet.getRange(startRow, 1, numRows, 9).getValues() : [];

  const map = new Map();
  existing.forEach((r, i) => {
    const city = r[2] ? r[2].toString().toLowerCase().trim() : '';
    const name = r[4] ? r[4].toString().toLowerCase().trim() : '';
    if (city === settlementName.toLowerCase().trim()) {
      map.set(`${name}|${city}`, { row: i + startRow });
    }
  });

  let newCnt = 0, updCnt = 0;
  const toAdd = [];

  newClients.forEach(c => {
    const name = (c['Наименование'] || '').trim();
    const key = `${name.toLowerCase()}|${settlementName.toLowerCase().trim()}`;
    const ex = map.get(key);

    const row = [
      'Россия', c['Субъект'], settlementName, c['Категория'], name,
      c['Адрес'], c['Контакты'], new Date(), 'Актуально'
    ];

    if (ex) {
      sheet.getRange(ex.row, 1, 1, 9).setValues([row]);
      map.delete(key);
      updCnt++;
    } else {
      toAdd.push(row);
      newCnt++;
    }
  });

  const closedCnt = map.size;
  map.forEach(v => sheet.getRange(v.row, 9, 1, 1).setValue('Вероятно, закрыта'));

  if (toAdd.length > 0) {
    sheet.getRange(sheet.getLastRow() + 1, 1, toAdd.length, 9).setValues(toAdd);
  }

  const total = parseInt(SCRIPT_PROPERTIES.getProperty('totalObjectsFoundOverall') || '0') + newCnt;
  SCRIPT_PROPERTIES.setProperty('totalObjectsFoundOverall', total.toString());

  return {new: newCnt, updated: updCnt, closed: closedCnt};
}

function prepareForSmartUpdate_(sheet, scopeType, name) {
  addLogEntry_(`Подготовка к обновлению для "${name || 'всей базы'}"...`, 'info');
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return;
  const statusRange = sheet.getRange(2, 9, lastRow - 1, 1);
  const statusData = statusRange.getValues();

  if (scopeType === 'full') {
    for (let i = 0; i < statusData.length; i++) statusData[i][0] = 'Ожидает проверки';
  } else {
    const colIndex = scopeType === 'city' ? 3 : 2;
    const scopeData = sheet.getRange(2, colIndex, lastRow - 1, 1).getValues();
    const nameLower = name.toLowerCase();
    for (let i = 0; i < scopeData.length; i++) {
      if (scopeData[i][0] && scopeData[i][0].toString().toLowerCase() === nameLower) {
        statusData[i][0] = 'Ожидает проверки';
      }
    }
  }
  statusRange.setValues(statusData);
}

function finalizeSmartUpdate_() {
  addLogEntry_(`Завершение обновления...`, 'info');
  const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return;
  const range = sheet.getRange(2, 9, lastRow - 1, 1);
  const statuses = range.getValues();
  let closedCount = 0;
  for (let i = 0; i < statuses.length; i++) {
    if (statuses[i][0] === 'Ожидает проверки') {
      statuses[i][0] = 'Вероятно, закрыта';
      closedCount++;
    }
  }
  if (closedCount > 0) {
    range.setValues(statuses);
    addLogEntry_(`Помечено как "Вероятно, закрыта": ${closedCount} объектов.`, 'info');
  }
}


// ===================================================================================
// === УТИЛИТЫ И ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ===
// ===================================================================================

function updateSpeedStats_(props, settlementIndex) {
    const now = Date.now();
    const lastCheck = parseInt(props.lastSpeedCheck || now);
    if (now - lastCheck > 20000) { // Update every 20 seconds
      const elapsedMin = (now - parseInt(props.startTime)) / 60000;
      const processed = parseInt(props.totalSettlementsProcessed || '0') + settlementIndex;
      const speed = elapsedMin > 1 ? (processed / elapsedMin).toFixed(1) : '0';
      SCRIPT_PROPERTIES.setProperty('citiesPerMinute', speed);
      SCRIPT_PROPERTIES.setProperty('lastSpeedCheck', now.toString());
    }
}

function updateProgressMessage_(regions, ri, si, totalSett, props, currentSettlement = '') {
  const regionProg = `${ri + 1}/${regions.length}`;
  const cityProg = totalSett > 0 ? `${si + 1}/${totalSett}` : '0/0';
  const msg = `Регион: ${regions[ri]} (${regionProg}) | Город: ${currentSettlement} (${cityProg})`;
  SCRIPT_PROPERTIES.setProperty('progressMessage', msg);
}

function getSettlementsForRegion_(regionName) {
  const regionType = detectRegionType_(regionName);
  if (regionType === 'city') return [regionName];

  const cacheKey = `settlements_v5_${regionName.replace(/\s/g, '_')}`;
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) return JSON.parse(cached);

  addLogEntry_(`Запрос списка городов для "${regionName}" к OpenStreetMap...`);
  const overpassQuery = `[out:json][timeout:300]; area["ISO3166-2"~"^RU-"][name="${regionName}"]->.searchArea; ( node["place"~"city|town"](area.searchArea); ); out;`;
  const options = { 'method': 'post', 'payload': 'data=' + encodeURIComponent(overpassQuery), 'muteHttpExceptions': true, 'headers': {'User-Agent': 'AppsScript-Client-OKB/1.0'} };
  
  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      const response = UrlFetchApp.fetch("https://overpass-api.de/api/interpreter", options);
      const responseCode = response.getResponseCode();
      if (responseCode === 200) {
        const data = JSON.parse(response.getContentText());
        if (!data.elements) return [];
        
        const settlementNames = Array.from(new Set(data.elements.map(el => el.tags?.name).filter(Boolean)));
        if (settlementNames.length > 0) {
          SCRIPT_CACHE.put(cacheKey, JSON.stringify(settlementNames), CACHE_EXPIRATION_SECONDS);
          addLogEntry_(`Найдено ${settlementNames.length} НП.`, 'info');
        }
        return settlementNames;
      }
      if (responseCode >= 500) { // 500, 502, 504, etc.
        throw new Error(`API OSM вернул ошибку ${responseCode}`);
      } else { // 4xx errors, etc. are final
        throw new Error(`API OSM вернул необрабатываемую ошибку ${responseCode}`);
      }
    } catch (e) {
      if (attempt < 3 && e.message.includes('50')) { // Retry only on 5xx errors
        addLogEntry_(`Ошибка получения НП (попытка ${attempt}/3): ${e.message}. Пауза ${20 * attempt} сек...`, 'warning');
        Utilities.sleep(20000 * attempt);
      } else {
        throw e; // Re-throw after last attempt or for non-retryable errors
      }
    }
  }
}

function detectRegionType_(name) {
  const regionKeywords = ['область', 'край', 'республика', 'автономный округ', 'ао', 'округ'];
  const lower = name.toLowerCase().trim();
  if (name === "Москва" || name === "Санкт-Петербург" || name === "Севастополь") return 'city';
  if (regionKeywords.some(k => lower.includes(k))) return 'region';
  return 'city';
}

function getUpdateStatus() {
  const props = SCRIPT_PROPERTIES.getProperties();
  let isUpdating = props.isUpdating === 'true';

  if (isUpdating) {
    const lastHeartbeat = parseInt(props.lastHeartbeat || '0');
    const now = Date.now();
    if (now - lastHeartbeat > 1500000) { // 25 min
      isUpdating = false; 
      SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
      const canBeContinued = props.currentRegionIndex && !props.finalSummary;
      const message = canBeContinued ? "Пауза истекла (>25 мин), но состояние сохранено. Нажмите 'Продолжить'." : "Процесс не отвечал > 25 мин и был остановлен.";
      SCRIPT_PROPERTIES.setProperty('progressMessage', message);
      addLogEntry_(message, canBeContinued ? 'warning' : 'error');
      deleteProcessTriggers_();
    }
  }

  const canContinue = !isUpdating && props.currentRegionIndex && !props.finalSummary;
  const finalSummary = props.finalSummary ? JSON.parse(props.finalSummary) : null;
  const regions = JSON.parse(props.regionsToProcess || '[]');
  const ri = parseInt(props.currentRegionIndex || '0');
  const si = parseInt(props.currentSettlementIndex || '0');
  const sett = JSON.parse(props.settlementsForCurrentRegion || '[]');
  let prog = 0;
  if (regions.length > 0 && ri < regions.length) {
    const regionsDone = ri;
    const settlementsInCurrentRegionDone = sett.length > 0 ? si / sett.length : 1;
    prog = ((regionsDone + settlementsInCurrentRegionDone) / regions.length) * 100;
  }
  
  return {
    isUpdating, canContinue,
    progressMessage: props.progressMessage || 'Ожидание...',
    cancelRequested: props.cancelRequested === 'true',
    liveLog: props.liveLog || '',
    finalSummary, totalProgress: prog,
    stats: {
      new: props.totalNew || '0', updated: props.totalUpdated || '0',
      closed: props.totalClosed || '0', speed: props.citiesPerMinute || '0'
    }
  };
}

function addLogEntry_(txt, type = 'info') {
  const colors = {info: '#94a3b8', success: '#22c55e', error: '#ef4444', warning: '#f59e0b'};
  const time = new Date().toLocaleTimeString('ru-RU');
  const entry = `<p style="color:${colors[type]};margin:2px 0">[${time}] ${txt}</p>`;
  const cur = SCRIPT_PROPERTIES.getProperty('liveLog') || '';
  const lines = (cur + entry).split('</p>').filter(Boolean);
  SCRIPT_PROPERTIES.setProperty('liveLog', lines.slice(-200).join('</p>') + '</p>');
}

function clearProcessProperties_() {
  const keys = ['isUpdating','totalObjectsFoundOverall','regionsToProcess','searchQuery','startTime','isFullUpdate','currentRegionIndex','currentSettlementIndex','settlementsForCurrentRegion','totalSettlementsProcessed','progressMessage','liveLog','finalSummary','cancelRequested','lastHeartbeat','consecutiveErrors','totalNew','totalUpdated','totalClosed','lastSpeedCheck','citiesPerMinute'];
  keys.forEach(k => SCRIPT_PROPERTIES.deleteProperty(k));
}

function deleteProcessTriggers_() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'mainProcessManager') ScriptApp.deleteTrigger(t);
  });
}

function createContinuationTrigger_(fn, delay) {
  deleteProcessTriggers_();
  ScriptApp.newTrigger(fn).timeBased().after(delay).create();
}

// ===================================================================================
// === ДАШБОРД И ЗАВЕРШЕНИЕ ===
// ===================================================================================
function resetState_(finalMessage, citiesProcessed, totalObjectsFound) {
  const props = SCRIPT_PROPERTIES.getProperties();
  const startTime = parseInt(props.startTime, 10);
  const durationStr = `${Math.floor((new Date().getTime() - startTime) / 60000)} мин`;
  const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
  
  try {
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    createDashboard_(sheet);
  } catch(e) {
    addLogEntry_(`Не удалось создать дашборд: ${e.message}`, 'error');
  }

  const dashboardSheet = spreadsheet.getSheetByName(DASHBOARD_SHEET_NAME);
  const summary = {
    message: finalMessage, duration: durationStr,
    citiesProcessed, totalObjectsFound,
    sheetUrl: spreadsheet.getUrl(),
    dashboardUrl: dashboardSheet ? `${spreadsheet.getUrl()}#gid=${dashboardSheet.getSheetId()}` : spreadsheet.getUrl()
  };
  SCRIPT_PROPERTIES.setProperties({'isUpdating': 'false', 'progressMessage': finalMessage, 'finalSummary': JSON.stringify(summary) });
  SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
  deleteProcessTriggers_();
}

function createDashboard_(sheet) {
  if (!sheet || sheet.getLastRow() < 2) return;
  const spreadsheet = sheet.getParent();
  let dashboardSheet = spreadsheet.getSheetByName(DASHBOARD_SHEET_NAME);
  if (dashboardSheet) dashboardSheet.clear(); 
  else dashboardSheet = spreadsheet.insertSheet(DASHBOARD_SHEET_NAME, 0); 
  
  dashboardSheet.setColumnWidths(1, 2, 300);
  const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4);

  const cityPivotTable = dashboardSheet.getRange('A1').createPivotTable(dataRange);
  cityPivotTable.addRowGroup(3).setDisplayName("Город");
  cityPivotTable.addPivotValue(3, SpreadsheetApp.PivotTableSummarizeFunction.COUNTA).setDisplayName('Количество объектов');

  const categoryPivotTable = dashboardSheet.getRange('A30').createPivotTable(dataRange);
  categoryPivotTable.addRowGroup(4).setDisplayName("Категория");
  categoryPivotTable.addPivotValue(4, SpreadsheetApp.PivotTableSummarizeFunction.COUNTA).setDisplayName('Количество объектов');

  SpreadsheetApp.flush();
}

// ===================================================================================
// === ПЛАНИРОВЩИК ===
// ===================================================================================
function runScheduledFullUpdate() {
  if (SCRIPT_PROPERTIES.getProperty('isUpdating') === 'true') {
    Logger.log('Автообновление пропущено, идет процесс.');
    return;
  }
  Logger.log('Запуск полного обновления по расписанию.');
  startUpdateProcess('', SCRIPT_PROPERTIES.getProperty('searchQuery') || 'ветеринарные клиники и зоомагазины');
}

function createScheduledTrigger(frequency) {
  deleteScheduledTrigger(); 
  let triggerBuilder = ScriptApp.newTrigger(SCHEDULED_TRIGGER_HANDLER).timeBased();
  if (frequency === 'weekly') {
    triggerBuilder.onWeekDay(ScriptApp.WeekDay.SUNDAY).atHour(3).inTimezone('Europe/Moscow').create();
  } else if (frequency === 'monthly') {
    triggerBuilder.onMonthDay(1).atHour(3).inTimezone('Europe/Moscow').create();
  } else if (frequency === 'weekly-morning') {
    triggerBuilder.onWeekDay(ScriptApp.WeekDay.SUNDAY).atHour(7).inTimezone('Europe/Moscow').create();
  }
  SCRIPT_PROPERTIES.setProperty('scheduleFrequency', frequency);
  return getScheduledTriggerStatus();
}

function deleteScheduledTrigger() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === SCHEDULED_TRIGGER_HANDLER) {
      ScriptApp.deleteTrigger(t);
    }
  });
  SCRIPT_PROPERTIES.deleteProperty('scheduleFrequency');
  return getScheduledTriggerStatus();
}

function getScheduledTriggerStatus() {
  const freq = SCRIPT_PROPERTIES.getProperty('scheduleFrequency');
  if (freq === 'weekly') return { status: 'Еженедельно (ночь ВС)' };
  if (freq === 'monthly') return { status: 'Ежемесячно (1-го числа)' };
  if (freq === 'weekly-morning') return { status: 'Еженедельно (ВС 07:00 МСК)' };
  return { status: 'Отключено' }; 
}
