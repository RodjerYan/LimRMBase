// ===================================================================================
// Code.gs – Серверная логика
// Версия: 20.0 – Финальная защита от спама и пустых координат
// ===================================================================================

// --- КОНФИГУРАЦИЯ ---
const SHEET_ID = '13HkruBN9a_Y5xF8nUGpoyo3N7nJxiTW3PPgqw8FsApI';
const SHEET_NAME = 'Base';
const DASHBOARD_SHEET_NAME = 'Сводка';
const ALL_REGIONS_LIST = ["Москва", "Московская область", "Санкт-Петербург", "Ленинградская область", "Республика Адыгея", "Республика Алтай", "Республика Башкортостан", "Республика Бурятия", "Республика Дагестан", "Республика Ингушетия", "Кабардино-Балкарская Республика", "Республика Калмыкия", "Карачаево-Черкесская Республика", "Республика Карелия", "Республика Коми", "Республика Крым", "Республика Марий Эл", "Республика Мордовия", "Республика Саха (Якутия)", "Республика Северная Осетия - Алания", "Республика Татарстан", "Республика Тыва", "Удмуртская Республика", "Республика Хакасия", "Чеченская Республика", "Чувашская Республика", "Алтайский край", "Забайкальский край", "Камчатский край", "Краснодарский край", "Красноярский край", "Пермский край", "Приморский край", "Ставропольский край", "Хабаровский край", "Амурская область", "Архангельская область", "Астраханская область", "Белгородская область", "Брянская область", "Владимирская область", "Волгоградская область", "Вологодская область", "Воронежская область", "Ивановская область", "Иркутская область", "Калининградская область", "Калужская область", "Кемеровская область", "Кировская область", "Костромская область", "Курганская область", "Курская область", "Липецкая область", "Магаданская область", "Мурманская область", "Нижегородская область", "Новгородская область", "Новосибирская область", "Омская область", "Оренбургская область", "Орловская область", "Пензенская область", "Псковская область", "Ростовская область", "Рязанская область", "Самарская область", "Саратовская область", "Сахалинская область", "Свердловская область", "Смоленская область", "Тамбовская область", "Тверская область", "Томская область", "Тульская область", "Тюменская область", "Ульяновская область", "Челябинская область", "Ярославская область", "Севастополь", "Еврейская автономная область", "Ненецкий автономный округ", "Ханты-Мансийский автономный округ - Югра", "Чукотский автономный округ", "Ямало-Ненецкий автономный округ"];
const CACHE_EXPIRATION_SECONDS = 86400; // 24 часа
const SCRIPT_PROPERTIES = PropertiesService.getScriptProperties();
const USER_PROPERTIES = PropertiesService.getUserProperties();
const SCRIPT_CACHE = CacheService.getScriptCache();
const SCHEDULED_TRIGGER_HANDLER = 'runScheduledFullUpdate';
const OSM_CACHE_EXPIRATION = 86400; // 24 часа

// ===================================================================================
// === ГЛАВНАЯ ФУНКЦИЯ ДЛЯ WEB-ИНТЕРФЕЙСА ===
function doGet() {
  return HtmlService.createTemplateFromFile('index')
    .evaluate()
    .setTitle('Панель Управления Базой')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// ===================================================================================
// === ФУНКЦИИ УПРАВЛЕНИЯ ПРОЦЕССОМ ===
function startUpdateProcess(region, searchQuery) {
  if (getUpdateStatus().isUpdating) return { status: 'error', message: 'Процесс обновления уже запущен.' };
  
  clearProcessProperties_();
  addLogEntry_('Инициализация нового процесса...', 'info');

  const regionsToProcess = region && region.trim() ? [region.trim()] : ALL_REGIONS_LIST;
  const isFullUpdate = !(region && region.trim());
  const now = new Date().getTime().toString();

  SCRIPT_PROPERTIES.setProperties({
    'isUpdating': 'true', 'totalObjectsFoundOverall': '0',
    'regionsToProcess': JSON.stringify(regionsToProcess), 'searchQuery': searchQuery || 'ветеринарные клиники и зоомагазины',
    'startTime': now, 'isFullUpdate': isFullUpdate.toString(),
    'currentRegionIndex': '0', 'currentSettlementIndex': '0', 'settlementsForCurrentRegion': '[]',
    'totalSettlementsProcessed': '0', 'lastHeartbeat': now, 'consecutiveErrors': '0',
    'totalNew': '0', 'totalUpdated': '0', 'totalClosed': '0',
    'lastSpeedCheck': now, 'citiesPerMinute': '0', 'lastApiCallTimestamp': '0'
  });

  // Сохраняем историю поиска для пользователя
  USER_PROPERTIES.setProperties({
    'lastRegion': region,
    'lastQuery': searchQuery
  });

  deleteProcessTriggers_();
  ScriptApp.newTrigger('mainProcessManager').timeBased().after(1000).create();
  return { status: 'success', message: 'Процесс запущен.' };
}

function continueUpdateProcess(region) {
  if (getUpdateStatus().isUpdating) return { status: 'error', message: 'Процесс обновления уже запущен.' };
  const props = SCRIPT_PROPERTIES.getProperties();
  if (!props.currentRegionIndex || props.finalSummary) return { status: 'error', message: 'Нет сохраненного состояния для продолжения.' };

  const fullRegionsList = JSON.parse(props.regionsToProcess || JSON.stringify(ALL_REGIONS_LIST));
  let targetRegionIndex = parseInt(props.currentRegionIndex, 10);
  let targetSettlementIndex = parseInt(props.currentSettlementIndex, 10);

  if (region && region.trim()) {
    const newRegion = region.trim();
    addLogEntry_(`Поиск нового региона для продолжения: "${newRegion}"...`, 'info');
    const foundIndex = fullRegionsList.findIndex(r => r.toLowerCase().includes(newRegion.toLowerCase()));
    
    if (foundIndex !== -1) {
      targetRegionIndex = foundIndex;
      targetSettlementIndex = 0; // Начинаем с начала нового региона
      SCRIPT_PROPERTIES.setProperties({
        'settlementsForCurrentRegion': '[]',
        'currentSettlementIndex': '0'
      });
      addLogEntry_(`Продолжение с нового региона: "${fullRegionsList[targetRegionIndex]}"`, 'success');
    } else {
      addLogEntry_(`Регион "${newRegion}" не найден. Продолжаем с прежнего места.`, 'warning');
    }
  }

  SCRIPT_PROPERTIES.setProperties({
    'isUpdating': 'true',
    'currentRegionIndex': targetRegionIndex.toString(),
    'currentSettlementIndex': targetSettlementIndex.toString(),
    'consecutiveErrors': '0'
  });

  SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
  SCRIPT_PROPERTIES.setProperty('lastHeartbeat', new Date().getTime().toString());

  deleteProcessTriggers_();
  ScriptApp.newTrigger('mainProcessManager').timeBased().after(1000).create();
  return { status: 'success', message: 'Процесс возобновлён.' };
}

function cancelUpdateProcess() {
  SCRIPT_PROPERTIES.setProperty('cancelRequested', 'true');
  return { status: 'success', message: 'Запрос на остановку отправлен.' };
}

function stopAllProcesses() {
  ScriptApp.getProjectTriggers().forEach(t => ScriptApp.deleteTrigger(t));
  clearProcessProperties_();
  SCRIPT_PROPERTIES.deleteProperty('scheduleFrequency');
  addLogEntry_('Все процессы и триггеры были аварийно остановлены.', 'warning');
}

// ===================================================================================
// === МЕНЕДЖЕР ПРОЦЕССА ===
function mainProcessManager() {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(60000)) { createContinuationTrigger_('mainProcessManager', 5000); return; }

  try {
    let props = SCRIPT_PROPERTIES.getProperties();
    if (props.isUpdating !== 'true') { deleteProcessTriggers_(); return; }
    if (props.cancelRequested === 'true') {
      addLogEntry_('Процесс остановлен пользователем.', 'warning');
      SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
      SCRIPT_PROPERTIES.setProperty('progressMessage', 'Пауза. Нажмите "Продолжить".');
      SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
      deleteProcessTriggers_();
      return;
    }

    SCRIPT_PROPERTIES.setProperty('lastHeartbeat', new Date().getTime().toString());

    const regions = JSON.parse(props.regionsToProcess);
    let regionIndex = parseInt(props.currentRegionIndex || '0');
    let settlementIndex = parseInt(props.currentSettlementIndex || '0');
    let settlements = JSON.parse(props.settlementsForCurrentRegion || '[]');

    updateProgressMessage_(regions, regionIndex, settlementIndex, settlements.length, props);

    if (settlementIndex >= settlements.length) {
      if (regionIndex > 0) { // Логируем завершение предыдущего региона
         addLogEntry_(`✅ Регион "${regions[regionIndex-1]}" полностью обработан.`, 'success');
      }
      if (regionIndex >= regions.length) {
        if (props.isFullUpdate === 'true') finalizeSmartUpdate_();
        resetState_('Обновление успешно завершено.', parseInt(props.totalSettlementsProcessed || '0'), parseInt(props.totalObjectsFoundOverall || '0'));
        return;
      }
      const currentRegion = regions[regionIndex];
      addLogEntry_(`--- Обработка нового региона: ${currentRegion} (${regionIndex + 1}/${regions.length}) ---`, 'success');

      const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
      if (props.isFullUpdate === 'true' && regionIndex === 0) prepareForSmartUpdate_(sheet, 'full', null);
      else if (props.isFullUpdate !== 'true') prepareForSmartUpdate_(sheet, detectRegionType_(currentRegion), currentRegion);

      let newSettlements = getSettlementsForRegion_(currentRegion) || [];
      if (newSettlements.length === 0) {
        addLogEntry_(`В "${currentRegion}" не найдено НП. Пропускаем.`, 'warning');
        SCRIPT_PROPERTIES.setProperty('currentRegionIndex', (regionIndex + 1).toString());
        createContinuationTrigger_('mainProcessManager', 1000);
        return;
      }

      SCRIPT_PROPERTIES.setProperties({
        'settlementsForCurrentRegion': JSON.stringify(newSettlements),
        'currentSettlementIndex': '0'
      });
      addLogEntry_(`Список НП для "${currentRegion}" получен (${newSettlements.length} шт). Начинаем обработку...`, 'info');
      createContinuationTrigger_('mainProcessManager', 1000);
      return;
    }

    const settlementName = settlements[settlementIndex];
    const regionName = regions[regionIndex];
    
    const result = searchByOSM_(settlementName, regionName);
    
    let newCnt = 0, updCnt = 0, closedCnt = 0;
    if (result && result.status === 'success' && result.data && result.data.length > 0) {
      const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
      try {
        const stats = smartUpdateSheet_(sheet, result.data, settlementName);
        newCnt = stats.new; updCnt = stats.updated; closedCnt = stats.closed;
        addLogEntry_(`→ ${settlementName}: +${newCnt} новых, ${updCnt} обновлено, ${closedCnt} закрыто`, 'success');
      } catch (e) {
        addLogEntry_(`ОШИБКА ЗАПИСИ в "${settlementName}": ${e.message}`, 'error');
      }
    } else {
      addLogEntry_(`→ ${settlementName}: ничего не найдено`, 'info');
    }

    const totalNew = parseInt(props.totalNew || '0') + newCnt;
    const totalUpd = parseInt(props.totalUpdated || '0') + updCnt;
    const totalClosed = parseInt(props.totalClosed || '0') + closedCnt;
    SCRIPT_PROPERTIES.setProperties({
      'totalNew': totalNew.toString(),
      'totalUpdated': totalUpd.toString(),
      'totalClosed': totalClosed.toString()
    });

    SCRIPT_PROPERTIES.setProperty('currentSettlementIndex', (settlementIndex + 1).toString());
    if (settlementIndex + 1 >= settlements.length) {
      const total = parseInt(props.totalSettlementsProcessed || '0') + settlements.length;
      SCRIPT_PROPERTIES.setProperty('totalSettlementsProcessed', total.toString());
      SCRIPT_PROPERTIES.setProperty('currentRegionIndex', (regionIndex + 1).toString());
    }
    SCRIPT_PROPERTIES.setProperty('consecutiveErrors', '0');
    createContinuationTrigger_('mainProcessManager', 3000);

  } catch (e) {
    addLogEntry_(`КРИТИЧЕСКАЯ ОШИБОКА: ${e.message}\n${e.stack}`, 'error');
    const errors = parseInt(SCRIPT_PROPERTIES.getProperty('consecutiveErrors') || '0') + 1;
    SCRIPT_PROPERTIES.setProperty('consecutiveErrors', errors.toString());
    if (errors >= 3) {
      try { GmailApp.sendEmail(Session.getEffectiveUser().getEmail(), 'Критическая ошибка в скрипте обновления базы', e.stack); } catch {}
    }
    SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
    deleteProcessTriggers_();
  } finally { lock.releaseLock(); }
}

// === ПОДРОБНЫЙ ПРОГРЕСС ===========================================================
function updateProgressMessage_(regions, ri, si, totalSett, props, currentSettlement = '') {
  const regionProg = `${ri + 1}/${regions.length}`;
  const cityProg = totalSett > 0 ? `${si + 1}/${totalSett}` : '0/0';
  const processedCities = parseInt(props.totalSettlementsProcessed || '0') + si;

  // Расчет скорости
  const now = Date.now();
  const lastCheck = parseInt(props.lastSpeedCheck || now);
  let speed = props.citiesPerMinute || '0';
  if (now - lastCheck > 20000) { // Обновляем скорость каждые 20 секунд
    const elapsedMin = (now - parseInt(props.startTime)) / 60000;
    speed = elapsedMin > 1 ? (processedCities / elapsedMin).toFixed(1) : '0';
    SCRIPT_PROPERTIES.setProperty('citiesPerMinute', speed);
    SCRIPT_PROPERTIES.setProperty('lastSpeedCheck', now.toString());
  }
  
  const regionName = regions[ri] || '';
  const settlementName = totalSett > 0 ? settlements[si] || '' : '';
  const msg = `Регион: [${regionProg}] ${regionName} | Город: (${cityProg}) ${settlementName} | Всего: ${processedCities} | Скорость: ${speed} НП/мин`;
  SCRIPT_PROPERTIES.setProperty('progressMessage', msg);
}

// ===================================================================================
// === OSM ПОИСК И ГЕОКОДИРОВАНИЕ ===
function searchByOSM_(settlementName, regionContext) {
  const cacheKey = `osm_v19_${settlementName}`;
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) { addLogEntry_(`КЭШ OSM для "${settlementName}"`, 'info'); return JSON.parse(cached); }

  addLogEntry_(`Поиск OSM для "${settlementName}"`, 'info');
  
  const query = `[out:json][timeout:180]; area[name="${settlementName}"]->.a; ( node["amenity"="veterinary"](area.a); way["amenity"="veterinary"](area.a); relation["amenity"="veterinary"](area.a); node["shop"~"pet|pet_supply"](area.a); way["shop"~"pet|pet_supply"](area.a); relation["shop"~"pet|pet_supply"](area.a); ); out body center geom;`;
  const options = { method: 'post', payload: 'data=' + encodeURIComponent(query), muteHttpExceptions: true };
  
  let response;
  try {
    response = UrlFetchApp.fetch('https://overpass-api.de/api/interpreter', options);
    if (response.getResponseCode() !== 200) throw new Error(`Overpass API вернул код ${response.getResponseCode()}`);
  } catch (e) {
    addLogEntry_(`OSM Overpass ошибка: ${e.message}`, 'error');
    return {status: 'error', message: 'OSM API недоступен'};
  }

  const data = JSON.parse(response.getContentText());
  if (!data.elements || data.elements.length === 0) return {status: 'success', data: []};
  
  const items = data.elements.slice(0, 50); // Ограничение для стабильности
  addLogEntry_(`Найдено ${data.elements.length} объектов, обрабатываем первые ${items.length} для стабильности.`, 'info');

  const clientsData = items.map(el => {
    const tags = el.tags || {};
    const lat = el.lat || el.center?.lat;
    const lon = el.lon || el.center?.lon;
    
    let address = '';
    // 1. Пытаемся собрать адрес из тегов
    if (tags['addr:street']) {
      address = `${tags['addr:city'] || settlementName}, ${tags['addr:street'] || ''} ${tags['addr:housenumber'] || ''}`;
    }
    
    // 2. Если тегов нет, обращаемся к геокодеру
    if (!address && lat && lon) {
      address = getAddressFromCoords_(lat, lon, settlementName);
    } else if (!address) {
      address = `${settlementName} (адрес не определен)`;
    }
    
    // Формируем финальную строку адреса
    const coordStr = (lat && lon) ? `(коорд: ${lat.toFixed(7)}, ${lon.toFixed(7)})` : `(коорд: не найдены)`;
    const finalAddress = `${coordStr} ${address}`.trim();

    return {
      'Наименование': tags.name || tags.brand || `${tags.amenity || tags.shop} (id:${el.id})`,
      'Адрес': finalAddress.replace(/, ,/g, ',').replace(/,$/, '').trim(),
      'Категория': tags.amenity === 'veterinary' ? 'Ветеринарная клиника' : 'Зоомагазин',
      'Контакты': tags.phone || tags['contact:phone'] || tags.website || 'Не указано',
      'Субъект': regionContext
    };
  });
  
  const result = {status: 'success', data: clientsData};
  SCRIPT_CACHE.put(cacheKey, JSON.stringify(result), OSM_CACHE_EXPIRATION);
  return result;
}

function getAddressFromCoords_(lat, lon, fallbackCity) {
    const geoCacheKey = `geo_v19_${lat}_${lon}`;
    const cached = SCRIPT_CACHE.get(geoCacheKey);
    if (cached) return cached;

    const services = [
        { name: 'Nominatim', url: `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}` },
        { name: 'BigDataCloud', url: `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=ru` },
        { name: 'GeocodeXYZ', url: `https://geocode.xyz/${lat},${lon}?json=1` }
    ];

    for (const service of services) {
        ensureApiRateLimit_(); // Глобальный ограничитель скорости
        try {
            const response = UrlFetchApp.fetch(service.url, {
                muteHttpExceptions: true,
                headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' }
            });

            if (response.getResponseCode() === 200) {
                const contentText = response.getContentText();
                let data;
                try {
                  data = JSON.parse(contentText);
                } catch(e) {
                  // Если ответ - не JSON, это спам или ошибка. Игнорируем.
                  addLogEntry_(`Геокодер (${service.name}) вернул не-JSON ответ, пропускаем.`, 'warning');
                  continue; 
                }

                let addressParts = {};
                if (service.name === 'Nominatim' && data.address) {
                    addressParts.city = data.address.city || data.address.town || data.address.village;
                    addressParts.road = data.address.road;
                    addressParts.house_number = data.address.house_number;
                    addressParts.postcode = data.address.postcode;
                } else if (service.name === 'BigDataCloud') {
                    addressParts.city = data.city;
                    addressParts.road = data.localityInfo?.administrative?.[2]?.name;
                    addressParts.postcode = data.postcode;
                } else if (service.name === 'GeocodeXYZ' && data.staddress) {
                    addressParts.city = data.city;
                    addressParts.road = data.staddress;
                    addressParts.house_number = data.stnumber;
                    addressParts.postcode = data.postal;
                }
                
                if (addressParts.city || addressParts.road) {
                    const fullAddress = [addressParts.city, addressParts.road, addressParts.house_number].filter(Boolean).join(', ');
                    const finalAddress = `${fullAddress} индекс - ${addressParts.postcode || '?'}`.trim();
                    SCRIPT_CACHE.put(geoCacheKey, finalAddress, OSM_CACHE_EXPIRATION * 30);
                    return finalAddress;
                }
            } else {
                addLogEntry_(`Геокодер (${service.name}) ошибка: API вернул код ${response.getResponseCode()}`, 'warning');
            }
        } catch (e) {
            addLogEntry_(`Геокодер (${service.name}) сетевая ошибка: ${e.message}`, 'warning');
        }
    }
    return `${fallbackCity} (адрес не определен)`;
}

// ===================================================================================
// === РАБОТА С ТАБЛИЦЕЙ ============================================================
function smartUpdateSheet_(sheet, newClients, settlementName) {
  if (!sheet || !newClients || newClients.length === 0) return {new: 0, updated: 0, closed: 0};

  const lastRow = sheet.getLastRow();
  const existingData = lastRow > 1 ? sheet.getRange(2, 1, lastRow - 1, 9).getValues() : [];
  
  const existingMap = new Map();
  existingData.forEach((row, index) => {
    const city = (row[2] || '').toString().toLowerCase().trim();
    const name = (row[4] || '').toString().toLowerCase().trim();
    if (city === settlementName.toLowerCase().trim()) {
      existingMap.set(`${name}|${city}`, { row: index + 2, data: row });
    }
  });

  let newCount = 0, updatedCount = 0;
  const toAdd = [], toUpdate = new Map();

  newClients.forEach(c => {
    const name = (c['Наименование'] || '').trim();
    const key = `${name.toLowerCase()}|${settlementName.toLowerCase().trim()}`;
    const existing = existingMap.get(key);

    const row = [
      'Россия', c['Субъект'] || '', settlementName, c['Категория'] || '',
      name, c['Адрес'] || '', c['Контакты'] || '', new Date(), 'Актуально'
    ];

    if (existing) {
      if (JSON.stringify(existing.data.slice(0, 7)) !== JSON.stringify(row.slice(0, 7))) {
        toUpdate.set(existing.row, row);
        updatedCount++;
      }
      existingMap.delete(key);
    } else {
      toAdd.push(row);
      newCount++;
    }
  });

  const closedCount = existingMap.size;
  const rangesToUpdate = [], valuesToUpdate = [];
  
  // Обновляем существующие
  toUpdate.forEach((value, key) => {
    rangesToUpdate.push(sheet.getRange(key, 1, 1, 9));
    valuesToUpdate.push(value);
  });

  // Помечаем закрытые
  existingMap.forEach(value => {
    rangesToUpdate.push(sheet.getRange(value.row, 9, 1, 1));
    valuesToUpdate.push(['Вероятно, закрыта']);
  });

  if (rangesToUpdate.length > 0) {
    sheet.getRangeList(rangesToUpdate.map(r => r.getA1Notation())).setValues(valuesToUpdate);
  }

  // Добавляем новые
  if (toAdd.length > 0) {
    sheet.getRange(sheet.getLastRow() + 1, 1, toAdd.length, 9).setValues(toAdd);
  }

  const total = parseInt(SCRIPT_PROPERTIES.getProperty('totalObjectsFoundOverall') || '0') + newCount;
  SCRIPT_PROPERTIES.setProperty('totalObjectsFoundOverall', total.toString());

  return {new: newCount, updated: updatedCount, closed: closedCount};
}

function prepareForSmartUpdate_(sheet, scopeType, name) {
  addLogEntry_(`Подготовка к обновлению для "${name || 'всей базы'}"...`, 'info');
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return;
  const statusRange = sheet.getRange(2, 9, lastRow - 1, 1);
  const statusData = statusRange.getValues();

  if (scopeType === 'full') {
    for (let i = 0; i < statusData.length; i++) {
      if (statusData[i][0] === 'Актуально') statusData[i][0] = 'Ожидает проверки';
    }
  } else {
    const colIndex = scopeType === 'city' ? 3 : 2;
    const scopeData = sheet.getRange(2, colIndex, lastRow - 1, 1).getValues();
    const nameLower = name.toLowerCase();
    for (let i = 0; i < scopeData.length; i++) {
      if (scopeData[i][0] && scopeData[i][0].toString().toLowerCase() === nameLower && statusData[i][0] === 'Актуально') {
        statusData[i][0] = 'Ожидает проверки';
      }
    }
  }
  statusRange.setValues(statusData);
}

function finalizeSmartUpdate_() {
  addLogEntry_(`Завершение обновления...`, 'info');
  const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return;
  const range = sheet.getRange(2, 9, lastRow - 1, 1);
  const statuses = range.getValues();
  let closedCount = 0;
  for (let i = 0; i < statuses.length; i++) {
    if (statuses[i][0] === 'Ожидает проверки') {
      statuses[i][0] = 'Вероятно, закрыта';
      closedCount++;
    }
  }
  if (closedCount > 0) {
    range.setValues(statuses);
    addLogEntry_(`Помечено как "Вероятно, закрыта": ${closedCount} объектов.`, 'info');
  }
}

// ===================================================================================
// === УТИЛИТЫ ===
function getSettlementsForRegion_(regionName) {
  const regionType = detectRegionType_(regionName);
  if (regionType === 'city') return [regionName];

  const cacheKey = `settlements_v19_${regionName.replace(/\s/g, '_')}`;
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) return JSON.parse(cached);

  addLogEntry_(`Запрос списка городов для "${regionName}" к OpenStreetMap...`);
  
  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      const overpassQuery = `[out:json][timeout:300]; area["ISO3166-2"~"^RU-"][name="${regionName}"]->.searchArea; ( node["place"~"city|town"](area.searchArea); ); out;`;
      const options = {method: 'post', payload: 'data=' + encodeURIComponent(overpassQuery), muteHttpExceptions: true };
      const response = UrlFetchApp.fetch("https://overpass-api.de/api/interpreter", options);
      if (response.getResponseCode() !== 200) {
        throw new Error(`API OSM вернул ошибку ${response.getResponseCode()}`);
      }
      const data = JSON.parse(response.getContentText());
      if (!data.elements) return [];
      
      const settlementNames = Array.from(new Set(data.elements.map(el => el.tags?.name).filter(Boolean)));
      if (settlementNames.length > 0) {
        SCRIPT_CACHE.put(cacheKey, JSON.stringify(settlementNames), CACHE_EXPIRATION_SECONDS);
      }
      return settlementNames;
    } catch (e) {
      addLogEntry_(`Ошибка получения списка НП (попытка ${attempt}/3): ${e.message}`, 'warning');
      if (attempt < 3) Utilities.sleep(30000 * attempt);
      else throw e;
    }
  }
}


function detectRegionType_(name) {
  const regionKeywords = ['область', 'край', 'республика', 'автономный округ', 'ао', 'округ'];
  const lower = name.toLowerCase().trim();
  if (name === "Москва" || name === "Санкт-Петербург" || name === "Севастополь") return 'city';
  if (regionKeywords.some(k => lower.includes(k))) return 'region';
  return 'city';
}

function ensureApiRateLimit_() {
  const lastCall = parseInt(SCRIPT_PROPERTIES.getProperty('lastApiCallTimestamp') || '0');
  const now = Date.now();
  const timeSinceLastCall = now - lastCall;
  const delay = 2000; // 2 секунды - безопасная задержка
  if (timeSinceLastCall < delay) {
    Utilities.sleep(delay - timeSinceLastCall);
  }
  SCRIPT_PROPERTIES.setProperty('lastApiCallTimestamp', Date.now().toString());
}


// ===================================================================================
// === СТАТУС, ЛОГИ, ТРИГГЕРЫ =========================================================
function getUpdateStatus() {
  const props = SCRIPT_PROPERTIES.getProperties();
  let isUpdating = props.isUpdating === 'true';

  if (isUpdating) {
    const lastHeartbeat = parseInt(props.lastHeartbeat || '0');
    const now = Date.now();
    
    if (now - lastHeartbeat > 1500000) { // 25 min
      isUpdating = false; 
      SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
      
      const canBeContinued = props.currentRegionIndex && !props.finalSummary;
      const message = canBeContinued
        ? "Пауза истекла (>25 мин), но состояние сохранено. Нажмите 'Продолжить'."
        : "Процесс не отвечал > 25 мин и был остановлен.";
      
      SCRIPT_PROPERTIES.setProperty('progressMessage', message);
      addLogEntry_(message, canBeContinued ? 'warning' : 'error');
      deleteProcessTriggers_();
    }
  }

  const canContinue = !isUpdating && props.currentRegionIndex && !props.finalSummary;
  const finalSummary = props.finalSummary ? JSON.parse(props.finalSummary) : null;
  const regions = JSON.parse(props.regionsToProcess || '[]');
  const ri = parseInt(props.currentRegionIndex || '0');
  const si = parseInt(props.currentSettlementIndex || '0');
  const sett = JSON.parse(props.settlementsForCurrentRegion || '[]');
  let prog = 0;
  if (regions.length > 0 && (isUpdating || canContinue)) {
    const regionProgress = ri / regions.length;
    const settlementProgressInRegion = sett.length > 0 ? si / sett.length : 0;
    prog = (regionProgress + (settlementProgressInRegion / regions.length)) * 100;
  }
  
  return {
    isUpdating, canContinue,
    progressMessage: props.progressMessage || 'Ожидание...',
    cancelRequested: props.cancelRequested === 'true',
    liveLog: props.liveLog || '',
    finalSummary, totalProgress: prog,
    stats: {
      new: props.totalNew || '0',
      updated: props.totalUpdated || '0',
      closed: props.totalClosed || '0',
      speed: props.citiesPerMinute || '0'
    }
  };
}

function getSearchHistory() {
  return USER_PROPERTIES.getProperties();
}

function addLogEntry_(txt, type = 'info') {
  const colors = {info: '#94a3b8', success: '#22c55e', error: '#ef4444', warning: '#f59e0b'};
  const time = new Date().toLocaleTimeString('ru-RU');
  const entry = `<p style="color:${colors[type]};margin:2px 0">[${time}] ${txt}</p>`;
  const cur = SCRIPT_PROPERTIES.getProperty('liveLog') || '';
  const lines = (cur + entry).split('</p>').filter(Boolean);
  const limited = lines.slice(-200).join('</p>') + '</p>';
  SCRIPT_PROPERTIES.setProperty('liveLog', limited);
  console.log(`[${time}] ${txt}`);
}

function clearProcessProperties_() {
  const keys = ['isUpdating','totalObjectsFoundOverall','regionsToProcess','searchQuery','startTime','isFullUpdate','currentRegionIndex','currentSettlementIndex','settlementsForCurrentRegion','totalSettlementsProcessed','progressMessage','liveLog','finalSummary','cancelRequested','lastHeartbeat','consecutiveErrors','totalNew','totalUpdated','totalClosed','lastSpeedCheck','citiesPerMinute', 'lastApiCallTimestamp'];
  keys.forEach(k => SCRIPT_PROPERTIES.deleteProperty(k));
}

function deleteProcessTriggers_() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'mainProcessManager') ScriptApp.deleteTrigger(t);
  });
}

function createContinuationTrigger_(fn, delay) {
  deleteProcessTriggers_();
  ScriptApp.newTrigger(fn).timeBased().after(delay).create();
}

// ===================================================================================
// === ДАШБОРД И ЗАВЕРШЕНИЕ ===
function resetState_(finalMessage, citiesProcessed, totalObjectsFound) {
  const props = SCRIPT_PROPERTIES.getProperties();
  const startTime = parseInt(props.startTime, 10);
  const durationStr = `${Math.floor((new Date().getTime() - startTime) / 60000)} мин`;
  const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
  
  try {
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    createDashboard_(sheet);
  } catch(e) {
    addLogEntry_(`Не удалось создать дашборд: ${e.message}`, 'error');
  }

  const dashboardSheet = spreadsheet.getSheetByName(DASHBOARD_SHEET_NAME);
  const summary = {
    message: finalMessage, duration: durationStr,
    citiesProcessed, totalObjectsFound,
    sheetUrl: spreadsheet.getUrl(),
    dashboardUrl: dashboardSheet ? `${spreadsheet.getUrl()}#gid=${dashboardSheet.getSheetId()}` : spreadsheet.getUrl()
  };
  SCRIPT_PROPERTIES.setProperties({'isUpdating': 'false', 'progressMessage': finalMessage, 'finalSummary': JSON.stringify(summary) });
  SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
  SCRIPT_PROPERTIES.deleteProperty('lastHeartbeat');
  SCRIPT_PROPERTIES.deleteProperty('consecutiveErrors');
  deleteProcessTriggers_();
}

function createDashboard_(sheet) {
  if (!sheet || sheet.getLastRow() < 2) return;
  const spreadsheet = sheet.getParent();
  let dashboardSheet = spreadsheet.getSheetByName(DASHBOARD_SHEET_NAME);
  if (dashboardSheet) dashboardSheet.clear(); 
  else dashboardSheet = spreadsheet.insertSheet(DASHBOARD_SHEET_NAME, 0); 
  
  dashboardSheet.setColumnWidths(1, 2, 300);
  const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4);

  const cityPivotTable = dashboardSheet.getRange('A1').createPivotTable(dataRange);
  cityPivotTable.addRowGroup(3).setDisplayName("Город");
  cityPivotTable.addPivotValue(3, SpreadsheetApp.PivotTableSummarizeFunction.COUNTA).setDisplayName('Количество объектов');

  const categoryPivotTable = dashboardSheet.getRange('A30').createPivotTable(dataRange);
  categoryPivotTable.addRowGroup(4).setDisplayName("Категория");
  categoryPivotTable.addPivotValue(4, SpreadsheetApp.PivotTableSummarizeFunction.COUNTA).setDisplayName('Количество объектов');

  SpreadsheetApp.flush();
}

// ===================================================================================
// === ПЛАНИРОВЩИК ===
function runScheduledFullUpdate() {
  if (SCRIPT_PROPERTIES.getProperty('isUpdating') === 'true') {
    Logger.log('Автообновление пропущено, идет процесс.');
    return;
  }
  Logger.log('Запуск полного обновления по расписанию.');
  startUpdateProcess('', USER_PROPERTIES.getProperty('lastQuery') || 'ветеринарные клиники и зоомагазины');
}

function createScheduledTrigger(frequency) {
  deleteScheduledTrigger(); 
  let triggerBuilder = ScriptApp.newTrigger(SCHEDULED_TRIGGER_HANDLER).timeBased();
  if (frequency === 'weekly') {
    triggerBuilder.onWeekDay(ScriptApp.WeekDay.SUNDAY).atHour(3).inTimezone('Europe/Moscow').create();
  } else if (frequency === 'monthly') {
    triggerBuilder.onMonthDay(1).atHour(3).inTimezone('Europe/Moscow').create();
  } else if (frequency === 'weekly-morning') {
    triggerBuilder.onWeekDay(ScriptApp.WeekDay.SUNDAY).atHour(7).inTimezone('Europe/Moscow').create();
  }
  SCRIPT_PROPERTIES.setProperty('scheduleFrequency', frequency);
  return getScheduledTriggerStatus();
}

function deleteScheduledTrigger() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === SCHEDULED_TRIGGER_HANDLER) {
      ScriptApp.deleteTrigger(t);
    }
  });
  SCRIPT_PROPERTIES.deleteProperty('scheduleFrequency');
  return getScheduledTriggerStatus();
}

function getScheduledTriggerStatus() {
  const freq = SCRIPT_PROPERTIES.getProperty('scheduleFrequency');
  if (freq === 'weekly') return { status: 'Еженедельно (ночь ВС)' };
  if (freq === 'monthly') return { status: 'Ежемесячно (1-го числа)' };
  if (freq === 'weekly-morning') return { status: 'Еженедельно (ВС 07:00 МСК)' };
  return { status: 'Отключено' }; 
}
