// ===================================================================================
// Code.gs – Серверная логика
// Версия: 22.0 – Интеллектуальное формирование адреса из тегов OSM
// ===================================================================================

// --- КОНФИГУРАЦИЯ ---
const SHEET_ID = '13HkruBN9a_Y5xF8nUGpoyo3N7nJxiTW3PPgqw8FsApI';
const SHEET_NAME = 'Base';
const DASHBOARD_SHEET_NAME = 'Сводка';
const ALL_REGIONS_LIST = ["Москва", "Московская область", "Санкт-Петербург", "Ленинградская область", "Республика Адыгея", "Республика Алтай", "Республика Башкортостан", "Республика Бурятия", "Республика Дагестан", "Республика Ингушетия", "Кабардино-Балкарская Республика", "Республика Калмыкия", "Карачаево-Черкесская Республика", "Республика Карелия", "Республика Коми", "Республика Крым", "Республика Марий Эл", "Республика Мордовия", "Республика Саха (Якутия)", "Республика Северная Осетия - Алания", "Республика Татарстан", "Республика Тыва", "Удмуртская Республика", "Республика Хакасия", "Чеченская Республика", "Чувашская Республика", "Алтайский край", "Забайкальский край", "Камчатский край", "Краснодарский край", "Красноярский край", "Пермский край", "Приморский край", "Ставропольный край", "Хабаровский край", "Амурская область", "Архангельская область", "Астраханская область", "Белгородская область", "Брянская область", "Владимирская область", "Волгоградская область", "Вологодская область", "Воронежская область", "Ивановская область", "Иркутская область", "Калининградская область", "Калужская область", "Кемеровская область", "Кировская область", "Костромская область", "Курганская область", "Курская область", "Липецкая область", "Магаданская область", "Мурманская область", "Нижегородская область", "Новгородская область", "Новосибирская область", "Омская область", "Оренбургская область", "Орловская область", "Пензенская область", "Псковская область", "Ростовская область", "Рязанская область", "Самарская область", "Саратовская область", "Сахалинская область", "Свердловская область", "Смоленская область", "Тамбовская область", "Тверская область", "Томская область", "Тульская область", "Тюменская область", "Ульяновская область", "Челябинская область", "Ярославская область", "Севастополь", "Еврейская автономная область", "Ненецкий автономный округ", "Ханты-Мансийский автономный округ - Югра", "Чукотский автономный округ", "Ямало-Ненецкий автономный округ"];
const CACHE_EXPIRATION_SECONDS = 86400; // 24 часа
const SCRIPT_PROPERTIES = PropertiesService.getScriptProperties();
const USER_PROPERTIES = PropertiesService.getUserProperties();
const SCRIPT_CACHE = CacheService.getScriptCache();
const SCHEDULED_TRIGGER_HANDLER = 'runScheduledFullUpdate';
const OSM_CACHE_EXPIRATION = 86400; // 24 часа

// ===================================================================================
// === ГЛАВНАЯ ФУНКЦИЯ ДЛЯ WEB-ИНТЕРФЕЙСА ===
function doGet() {
  return HtmlService.createTemplateFromFile('index')
    .evaluate()
    .setTitle('Панель Управления Базой')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// ===================================================================================
// === ФУНКЦИИ УПРАВЛЕНИЯ ПРОЦЕССОМ ===
function startUpdateProcess(region, searchQuery) {
  if (getUpdateStatus().isUpdating) return { status: 'error', message: 'Процесс обновления уже запущен.' };
  
  clearProcessProperties_();
  addLogEntry_('Инициализация нового процесса...', 'info');

  const regionsToProcess = region && region.trim() ? [region.trim()] : ALL_REGIONS_LIST;
  const isFullUpdate = !(region && region.trim());
  const now = new Date().getTime().toString();

  SCRIPT_PROPERTIES.setProperties({
    'isUpdating': 'true', 'totalObjectsFoundOverall': '0',
    'regionsToProcess': JSON.stringify(regionsToProcess), 'searchQuery': searchQuery || 'ветеринарные клиники и зоомагазины',
    'startTime': now, 'isFullUpdate': isFullUpdate.toString(),
    'currentRegionIndex': '0', 'currentSettlementIndex': '0', 'settlementsForCurrentRegion': '[]',
    'totalSettlementsProcessed': '0', 'lastHeartbeat': now, 'consecutiveErrors': '0',
    'totalNew': '0', 'totalUpdated': '0', 'totalClosed': '0',
    'lastSpeedCheck': now, 'citiesPerMinute': '0'
  });

  // Сохраняем историю поиска для пользователя
  USER_PROPERTIES.setProperties({
    'lastRegion': region,
    'lastQuery': searchQuery
  });

  deleteProcessTriggers_();
  ScriptApp.newTrigger('mainProcessManager').timeBased().after(1000).create();
  return { status: 'success', message: 'Процесс запущен.' };
}

function continueUpdateProcess(region) {
  if (getUpdateStatus().isUpdating) return { status: 'error', message: 'Процесс обновления уже запущен.' };
  const props = SCRIPT_PROPERTIES.getProperties();
  if (!props.currentRegionIndex || props.finalSummary) return { status: 'error', message: 'Нет сохраненного состояния для продолжения.' };

  const fullRegionsList = JSON.parse(props.regionsToProcess || JSON.stringify(ALL_REGIONS_LIST));
  let targetRegionIndex = parseInt(props.currentRegionIndex, 10);
  let targetSettlementIndex = parseInt(props.currentSettlementIndex, 10);

  if (region && region.trim()) {
    const newRegion = region.trim();
    addLogEntry_(`Поиск нового региона для продолжения: "${newRegion}"...`, 'info');
    const foundIndex = fullRegionsList.findIndex(r => r.toLowerCase().includes(newRegion.toLowerCase()));
    
    if (foundIndex !== -1) {
      targetRegionIndex = foundIndex;
      targetSettlementIndex = 0; // Начинаем с начала нового региона
      SCRIPT_PROPERTIES.setProperties({
        'settlementsForCurrentRegion': '[]',
        'currentSettlementIndex': '0'
      });
      addLogEntry_(`Продолжение с нового региона: "${fullRegionsList[targetRegionIndex]}"`, 'success');
    } else {
      addLogEntry_(`Регион "${newRegion}" не найден. Продолжаем с прежнего места.`, 'warning');
    }
  }

  SCRIPT_PROPERTIES.setProperties({
    'isUpdating': 'true',
    'currentRegionIndex': targetRegionIndex.toString(),
    'currentSettlementIndex': targetSettlementIndex.toString(),
    'consecutiveErrors': '0'
  });

  SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
  SCRIPT_PROPERTIES.setProperty('lastHeartbeat', new Date().getTime().toString());

  deleteProcessTriggers_();
  ScriptApp.newTrigger('mainProcessManager').timeBased().after(1000).create();
  return { status: 'success', message: 'Процесс возобновлён.' };
}

function cancelUpdateProcess() {
  SCRIPT_PROPERTIES.setProperty('cancelRequested', 'true');
  return { status: 'success', message: 'Запрос на остановку отправлен.' };
}

function stopAllProcesses() {
  ScriptApp.getProjectTriggers().forEach(t => ScriptApp.deleteTrigger(t));
  clearProcessProperties_();
  SCRIPT_PROPERTIES.deleteProperty('scheduleFrequency');
  addLogEntry_('Все процессы и триггеры были аварийно остановлены.', 'warning');
}

// ===================================================================================
// === МЕНЕДЖЕР ПРОЦЕССА ===
function mainProcessManager() {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(60000)) { createContinuationTrigger_('mainProcessManager', 5000); return; }

  try {
    let props = SCRIPT_PROPERTIES.getProperties();
    if (props.isUpdating !== 'true') { deleteProcessTriggers_(); return; }
    if (props.cancelRequested === 'true') {
      addLogEntry_('Процесс остановлен пользователем.', 'warning');
      SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
      SCRIPT_PROPERTIES.setProperty('progressMessage', 'Пауза. Нажмите "Продолжить".');
      SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
      deleteProcessTriggers_();
      return;
    }

    SCRIPT_PROPERTIES.setProperty('lastHeartbeat', new Date().getTime().toString());

    const regions = JSON.parse(props.regionsToProcess);
    let regionIndex = parseInt(props.currentRegionIndex || '0');
    let settlementIndex = parseInt(props.currentSettlementIndex || '0');
    let settlements = JSON.parse(props.settlementsForCurrentRegion || '[]');

    updateProgressMessage_(regions, regionIndex, settlementIndex, settlements, props);

    if (settlementIndex >= settlements.length) {
      if (regionIndex > 0 && settlements.length > 0) {
         addLogEntry_(`✅ Регион "${regions[regionIndex-1]}" полностью обработан.`, 'success');
      }
      if (regionIndex >= regions.length) {
        if (props.isFullUpdate === 'true') finalizeSmartUpdate_();
        resetState_('Обновление успешно завершено.', parseInt(props.totalSettlementsProcessed || '0'), parseInt(props.totalObjectsFoundOverall || '0'));
        return;
      }
      const currentRegion = regions[regionIndex];
      addLogEntry_(`--- Обработка нового региона: ${currentRegion} (${regionIndex + 1}/${regions.length}) ---`, 'success');

      const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
      if (props.isFullUpdate === 'true' && regionIndex === 0) prepareForSmartUpdate_(sheet, 'full', null);
      else if (props.isFullUpdate !== 'true') prepareForSmartUpdate_(sheet, detectRegionType_(currentRegion), currentRegion);

      let newSettlements = getSettlementsForRegion_(currentRegion) || [];
      if (newSettlements.length === 0) {
        addLogEntry_(`В "${currentRegion}" не найдено НП. Пропускаем.`, 'warning');
        SCRIPT_PROPERTIES.setProperty('currentRegionIndex', (regionIndex + 1).toString());
        createContinuationTrigger_('mainProcessManager', 1000);
        return;
      }

      SCRIPT_PROPERTIES.setProperties({
        'settlementsForCurrentRegion': JSON.stringify(newSettlements),
        'currentSettlementIndex': '0'
      });
      addLogEntry_(`Список НП для "${currentRegion}" получен (${newSettlements.length} шт). Начинаем обработку...`, 'info');
      createContinuationTrigger_('mainProcessManager', 1000);
      return;
    }

    const settlementName = settlements[settlementIndex];
    const regionName = regions[regionIndex];
    
    const result = searchByOSM_(settlementName, regionName);
    
    let newCnt = 0, updCnt = 0, closedCnt = 0;
    if (result && result.status === 'success' && result.data && result.data.length > 0) {
      const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
      try {
        const stats = smartUpdateSheet_(sheet, result.data, settlementName);
        newCnt = stats.new; updCnt = stats.updated; closedCnt = stats.closed;
        addLogEntry_(`→ ${settlementName}: +${newCnt} новых, ${updCnt} обновлено, ${closedCnt} закрыто`, 'success');
      } catch (e) {
        addLogEntry_(`ОШИБКА ЗАПИСИ в "${settlementName}": ${e.message}`, 'error');
      }
    } else {
      addLogEntry_(`→ ${settlementName}: ничего не найдено`, 'info');
    }

    const totalNew = parseInt(props.totalNew || '0') + newCnt;
    const totalUpd = parseInt(props.totalUpdated || '0') + updCnt;
    const totalClosed = parseInt(props.totalClosed || '0') + closedCnt;
    SCRIPT_PROPERTIES.setProperties({
      'totalNew': totalNew.toString(),
      'totalUpdated': updCnt.toString(),
      'totalClosed': closedCnt.toString()
    });

    SCRIPT_PROPERTIES.setProperty('currentSettlementIndex', (settlementIndex + 1).toString());
    if (settlementIndex + 1 >= settlements.length) {
      const total = parseInt(props.totalSettlementsProcessed || '0') + settlements.length;
      SCRIPT_PROPERTIES.setProperty('totalSettlementsProcessed', total.toString());
      SCRIPT_PROPERTIES.setProperty('currentRegionIndex', (regionIndex + 1).toString());
    }
    SCRIPT_PROPERTIES.setProperty('consecutiveErrors', '0');
    createContinuationTrigger_('mainProcessManager', 3000);

  } catch (e) {
    addLogEntry_(`КРИТИЧЕСКАЯ ОШИБОКА: ${e.message}\n${e.stack}`, 'error');
    const errors = parseInt(SCRIPT_PROPERTIES.getProperty('consecutiveErrors') || '0') + 1;
    SCRIPT_PROPERTIES.setProperty('consecutiveErrors', errors.toString());
    if (errors >= 3) {
      try { GmailApp.sendEmail(Session.getEffectiveUser().getEmail(), 'Критическая ошибка в скрипте обновления базы', e.stack); } catch {}
    }
    SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
    deleteProcessTriggers_();
  } finally { lock.releaseLock(); }
}

// === ПОДРОБНЫЙ ПРОГРЕСС ===========================================================
function updateProgressMessage_(regions, ri, si, settlements, props) {
  if (!regions || !settlements) return; // Defensive check
  const totalSett = settlements.length;
  const regionProg = `${ri + 1}/${regions.length}`;
  const cityProg = totalSett > 0 ? `${si + 1}/${totalSett}` : '0/0';
  const processedCities = parseInt(props.totalSettlementsProcessed || '0') + si;

  // Расчет скорости
  const now = Date.now();
  const lastCheck = parseInt(props.lastSpeedCheck || now);
  let speed = props.citiesPerMinute || '0';
  if (now - lastCheck > 20000) { // Обновляем скорость каждые 20 секунд
    const elapsedMin = (now - parseInt(props.startTime)) / 60000;
    if (elapsedMin > 0.5) { // Начинаем считать после 30 секунд работы
      speed = (processedCities / elapsedMin).toFixed(1);
      SCRIPT_PROPERTIES.setProperties({ 'lastSpeedCheck': now.toString(), 'citiesPerMinute': speed });
    }
  }

  const regionName = regions[ri] || '...';
  const settlName = settlements[si] || '...';

  const progressMessage = `Регион: ${regionName} [${regionProg}] | НП: ${settlName} [${cityProg}]`;
  
  // Расчет общего прогресса
  const totalRegions = regions.length;
  const regionWeight = 1 / totalRegions;
  const settlementProgress = totalSett > 0 ? si / totalSett : 1;
  const totalProgress = ((ri + settlementProgress) * regionWeight) * 100;
  
  SCRIPT_PROPERTIES.setProperties({ 
    'progressMessage': progressMessage,
    'totalProgress': Math.floor(totalProgress).toString()
  });
}

// ===================================================================================
// === РАБОТА С OpenStreetMap ===
function searchByOSM_(settlementName, regionName) {
  addLogEntry_(`Поиск OSM для "${settlementName}"`, 'info');
  const cacheKey = `osm_${regionName}_${settlementName}_vet_pet_shops`; // Specific cache key for reliability
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) {
    addLogEntry_('Данные OSM взяты из кэша.', 'info');
    return JSON.parse(cached);
  }

  const overpassUrl = 'https://overpass-api.de/api/interpreter';
  // Оптимизированный запрос: ищет границу НП (уточняя, что это город/посёлок),
  // а затем ищет объекты только внутри этой границы.
  const query = `
    [out:json][timeout:180];
    area["name"="${regionName}"]->.region;
    area["name"="${settlementName}"]["place"~"city|town"](area.region)->.searchArea;
    (
      nwr["amenity"="veterinary"](area.searchArea);
      nwr["shop"="pet"](area.searchArea);
    );
    out center;
  `.trim();

  const options = {
    'method': 'post',
    'contentType': 'application/x-www-form-urlencoded',
    'payload': { 'data': query },
    'muteHttpExceptions': true
  };
  
  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      const response = UrlFetchApp.fetch(overpassUrl, options);
      const responseCode = response.getResponseCode();
      if (responseCode === 200) {
        const data = JSON.parse(response.getContentText());
        let elements = data.elements;

        const limit = 50;
        if (elements.length > limit) {
          addLogEntry_(`Найдено ${elements.length} объектов, обрабатываем первые ${limit} для стабильности.`, 'warning');
          elements = elements.slice(0, limit);
        }

        const formattedData = elements.map(el => {
          const tags = el.tags || {};
          const coords = el.center ? { lat: el.center.lat, lon: el.center.lon } : { lat: el.lat, lon: el.lon };
          return {
            id: `osm-${el.id}`,
            name: tags.name || 'Без названия',
            address: buildAddressFromTags_(tags, coords),
            phone: tags.phone || tags['contact:phone'] || '',
            website: tags.website || tags['contact:website'] || '',
            lat: coords.lat,
            lon: coords.lon,
            source: 'OSM',
            city: settlementName
          };
        });
        
        const result = { status: 'success', data: formattedData };
        SCRIPT_CACHE.put(cacheKey, JSON.stringify(result), OSM_CACHE_EXPIRATION);
        return result;

      } else {
        addLogEntry_(`Overpass ошибка (попытка ${attempt}/3): HTTP ${responseCode}`, 'error');
        if (attempt < 3) Utilities.sleep(15000 * attempt);
      }
    } catch (e) {
      addLogEntry_(`Overpass ошибка сети (попытка ${attempt}/3): ${e.message}`, 'error');
      if (attempt < 3) Utilities.sleep(15000 * attempt);
    }
  }
  return { status: 'error', message: 'Не удалось получить данные от Overpass API после 3 попыток.' };
}

// === УЛУЧШЕННАЯ ФУНКЦИЯ ФОРМИРОВАНИЯ АДРЕСА ===
function buildAddressFromTags_(tags, coords) {
  const addressParts = [];
  
  // 1. Город/Населенный пункт
  const city = tags['addr:city'] || tags['addr:place'] || tags['addr:settlement'];
  if (city) addressParts.push(city);
  
  // 2. Улица
  const street = tags['addr:street'];
  if (street) addressParts.push(street);
  
  // 3. Номер дома
  const houseNumber = tags['addr:housenumber'];
  if (houseNumber) {
    // Если есть улица, добавляем "д." или "стр." и т.д.
    const prefix = street ? (houseNumber.match(/[а-яА-Я]/) ? '' : 'д. ') : '';
    addressParts.push(`${prefix}${houseNumber}`);
  }
  
  // Если удалось собрать хотя бы что-то, возвращаем собранный адрес
  if (addressParts.length > 0) {
    return addressParts.join(', ');
  }
  
  // В противном случае, возвращаем координаты как запасной вариант
  return `Координаты: ${coords.lat.toFixed(5)}, ${coords.lon.toFixed(5)}`;
}

function getSettlementsForRegion_(region) {
  const cacheKey = `settlements_${region}`;
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) return JSON.parse(cached);

  addLogEntry_(`Запрос списка городов для "${region}" к OpenStreetMap...`, 'info');
  const overpassUrl = 'https://overpass-api.de/api/interpreter';
  const query = `
    [out:json][timeout:60];
    area["name"="${region}"]->.searchArea;
    (
      node["place"~"city|town"](area.searchArea);
    );
    out body;
  `.trim();
  
  try {
    const response = UrlFetchApp.fetch(overpassUrl, { method: 'post', payload: { 'data': query }, muteHttpExceptions: true });
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      const settlements = [...new Set(data.elements.map(e => e.tags.name).filter(Boolean))]
        .sort((a, b) => a.localeCompare(b, 'ru'));
      SCRIPT_CACHE.put(cacheKey, JSON.stringify(settlements), CACHE_EXPIRATION_SECONDS);
      return settlements;
    } else {
      addLogEntry_(`Не удалось получить список НП для "${region}". Код: ${response.getResponseCode()}`, 'error');
      return [];
    }
  } catch (e) {
    addLogEntry_(`Ошибка сети при получении списка НП для "${region}": ${e.message}`, 'error');
    return [];
  }
}

// ===================================================================================
// === РАБОТА С GOOGLE ТАБЛИЦЕЙ (SMART UPDATE) ===

function smartUpdateSheet_(sheet, newData, currentCity) {
  if (!newData || newData.length === 0) return { new: 0, updated: 0, closed: 0 };
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const dataRange = sheet.getDataRange();
  const allData = dataRange.getValues().slice(1);
  const cityColIndex = headers.indexOf('Город');
  const idColIndex = headers.indexOf('ID');

  // Фильтруем данные только для текущего города, чтобы не сканировать всю таблицу каждый раз
  const existingCityData = allData.filter(row => row[cityColIndex] === currentCity);
  const existingIds = new Set(existingCityData.map(row => row[idColIndex]));

  const toAdd = [];
  const toUpdate = [];

  newData.forEach(newItem => {
    if (existingIds.has(newItem.id)) {
      // Это обновление, но мы его пропускаем, так как smartUpdate обновит все сразу
    } else {
      toAdd.push([
        newItem.id, newItem.name, newItem.address, newItem.phone, newItem.website,
        newItem.lat, newItem.lon, newItem.source, new Date(), new Date(),
        currentCity, 'active'
      ]);
    }
  });

  if (toAdd.length > 0) {
    sheet.getRange(sheet.getLastRow() + 1, 1, toAdd.length, toAdd[0].length).setValues(toAdd);
  }

  // Обновляем все записи для текущего города, которые были помечены для обновления
  const cityRowsToUpdate = allData.reduce((acc, row, index) => {
    if (row[cityColIndex] === currentCity && row[idColIndex].toString().startsWith('osm-') && row[headers.length-1] === 'marked_for_update') {
      const newDataItem = newData.find(item => item.id === row[idColIndex]);
      if (newDataItem) {
        // [range, values]
        acc.push([
          `B${index + 2}:E${index + 2}`,
          [newDataItem.name, newDataItem.address, newDataItem.phone, newDataItem.website]
        ]);
        acc.push([
          `I${index + 2}:I${index + 2}`,
          [[new Date()]] // Дата обновления
        ]);
         acc.push([
          `L${index + 2}:L${index + 2}`,
          [['active']] // Статус
        ]);
      }
    }
    return acc;
  }, []);
  
  if(cityRowsToUpdate.length > 0) {
    const ranges = cityRowsToUpdate.map(item => item[0]);
    const values = cityRowsToUpdate.map(item => item[1]);
    
    // Используем batchUpdate для групповой записи
    const requests = ranges.map((range, i) => ({
      range: `${SHEET_NAME}!${range}`,
      values: Array.isArray(values[i][0]) ? values[i] : [values[i]]
    }));
    
    Sheets.Spreadsheets.Values.batchUpdate({ data: requests, valueInputOption: "USER_ENTERED" }, SHEET_ID);
  }
  
  // Подсчитываем закрытые
  const activeIdsInNewData = new Set(newData.map(item => item.id));
  const closedCount = existingCityData.filter(row =>
    row[idColIndex].toString().startsWith('osm-') &&
    !activeIdsInNewData.has(row[idColIndex]) &&
    row[headers.length-1] !== 'closed'
  ).length;

  return { new: toAdd.length, updated: cityRowsToUpdate.length / 3, closed: closedCount }; // Делим на 3, так как 3 записи на объект
}

function prepareForSmartUpdate_(sheet, type, region) {
  addLogEntry_(`Подготовка к обновлению для "${region || 'всей базы'}"...`, 'info');
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const data = sheet.getDataRange().getValues().slice(1);
  const sourceColIndex = headers.indexOf('Источник');
  const statusColIndex = headers.indexOf('Статус');
  const regionColIndex = headers.indexOf('Регион') > -1 ? headers.indexOf('Регион') : headers.indexOf('Город'); // Адаптация

  const rangesToUpdate = [];
  data.forEach((row, index) => {
    const isOsmSource = row[sourceColIndex] === 'OSM';
    const isActive = row[statusColIndex] === 'active';
    let shouldMark = false;

    if (type === 'full' && isOsmSource && isActive) {
      shouldMark = true;
    } else if (type === 'region' && isOsmSource && isActive && row[regionColIndex].includes(region)) {
      shouldMark = true;
    } else if (type === 'city' && isOsmSource && isActive && row[regionColIndex] === region) {
      shouldMark = true;
    }
    
    if (shouldMark) {
      // +2 потому что index с 0, а строки в таблице с 1, и +1 заголовок
      rangesToUpdate.push(`${SHEET_NAME}!L${index + 2}`);
    }
  });

  if (rangesToUpdate.length > 0) {
    const requests = rangesToUpdate.map(range => ({
      range: range,
      values: [['marked_for_update']]
    }));
    // Разбиваем на чанки по 500, чтобы не превысить лимиты API
    for (let i = 0; i < requests.length; i += 500) {
        const chunk = requests.slice(i, i + 500);
        Sheets.Spreadsheets.Values.batchUpdate({ data: chunk, valueInputOption: "RAW" }, SHEET_ID);
    }
    addLogEntry_(`Помечено ${rangesToUpdate.length} записей для проверки.`, 'info');
  } else {
    addLogEntry_(`Нет активных записей OSM для проверки в "${region || 'базе'}".`, 'info');
  }
}

function finalizeSmartUpdate_() {
  addLogEntry_('Завершение "умного" обновления: закрытие устаревших записей...', 'info');
  const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
  const data = sheet.getDataRange().getValues();
  const headers = data.shift();
  const statusColIndex = headers.indexOf('Статус');
  
  const rangesToUpdate = [];
  data.forEach((row, index) => {
    if (row[statusColIndex] === 'marked_for_update') {
      rangesToUpdate.push(`${SHEET_NAME}!L${index + 2}`);
    }
  });

  if (rangesToUpdate.length > 0) {
    const requests = rangesToUpdate.map(range => ({
      range: range,
      values: [['closed']]
    }));
    for (let i = 0; i < requests.length; i += 500) {
      const chunk = requests.slice(i, i + 500);
      Sheets.Spreadsheets.Values.batchUpdate({ data: chunk, valueInputOption: "RAW" }, SHEET_ID);
    }
    addLogEntry_(`${rangesToUpdate.length} устаревших записей было закрыто.`, 'success');
  } else {
    addLogEntry_('Не найдено устаревших записей для закрытия.', 'info');
  }
}

// ===================================================================================
// === ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ===
function getUpdateStatus() {
  const props = SCRIPT_PROPERTIES.getProperties();
  const logs = getLogEntries_();
  const stats = {
    new: props.totalNew || '0',
    updated: props.totalUpdated || '0',
    closed: props.totalClosed || '0',
    speed: props.citiesPerMinute || '0'
  };
  return {
    isUpdating: props.isUpdating === 'true',
    canContinue: !!props.currentRegionIndex && props.isUpdating !== 'true' && !props.finalSummary,
    cancelRequested: props.cancelRequested === 'true',
    progressMessage: props.progressMessage || 'Ожидание...',
    totalProgress: props.totalProgress || '0',
    liveLog: logs,
    finalSummary: props.finalSummary ? JSON.parse(props.finalSummary) : null,
    stats: stats,
  };
}

function getSearchHistory() {
  return USER_PROPERTIES.getProperties();
}

function addLogEntry_(message, type) {
  const timestamp = new Date().toLocaleTimeString('ru-RU');
  const logEntry = `<p class="log-${type}">[${timestamp}] ${message}</p>`;
  let logs = SCRIPT_PROPERTIES.getProperty('liveLog') || '';
  const logLines = logs.split('</p>').filter(Boolean);
  if (logLines.length > 100) {
    logs = logLines.slice(logLines.length - 100).join('</p>') + '</p>';
  }
  SCRIPT_PROPERTIES.setProperty('liveLog', logs + logEntry);
}

function getLogEntries_() {
  return SCRIPT_PROPERTIES.getProperty('liveLog') || '';
}

function clearProcessProperties_() {
  const keys = SCRIPT_PROPERTIES.getKeys().filter(k => k !== 'scheduleFrequency');
  if(keys.length > 0) SCRIPT_PROPERTIES.deleteProperties(keys);
}

function deleteProcessTriggers_() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'mainProcessManager') {
      ScriptApp.deleteTrigger(t);
    }
  });
}

function createContinuationTrigger_(handler, delay) {
  deleteProcessTriggers_();
  ScriptApp.newTrigger(handler).timeBased().after(delay).create();
}

function resetState_(finalMessage, cities, objects) {
  deleteProcessTriggers_();
  const startTime = parseInt(SCRIPT_PROPERTIES.getProperty('startTime') || Date.now());
  const duration = ((Date.now() - startTime) / 60000).toFixed(1) + ' мин';
  const summary = {
    message: finalMessage, duration: duration, citiesProcessed: cities,
    totalObjectsFound: objects,
    sheetUrl: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/edit#gid=0`,
    dashboardUrl: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/edit#gid=${SpreadsheetApp.openById(SHEET_ID).getSheetByName(DASHBOARD_SHEET_NAME).getSheetId()}`
  };
  SCRIPT_PROPERTIES.setProperty('finalSummary', JSON.stringify(summary));
  SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
  addLogEntry_(`${finalMessage} Время выполнения: ${duration}.`, 'success');
  
  // Обновляем дашборд
  try { updateDashboard_(); } catch (e) { addLogEntry_(`Не удалось обновить дашборд: ${e.message}`, 'error');}
}

function detectRegionType_(regionName) {
  if (regionName.toLowerCase().includes('область') || regionName.toLowerCase().includes('край') || regionName.toLowerCase().includes('республика')) {
    return 'region';
  }
  return 'city';
}

// === ПЛАНИРОВЩИК ===
function createScheduledTrigger(frequency) {
  deleteScheduledTrigger();
  let triggerBuilder;
  switch (frequency) {
    case 'weekly':
      triggerBuilder = ScriptApp.newTrigger(SCHEDULED_TRIGGER_HANDLER).timeBased().onWeekDay(ScriptApp.WeekDay.SUNDAY).atHour(2);
      break;
    case 'weekly-morning':
      triggerBuilder = ScriptApp.newTrigger(SCHEDULED_TRIGGER_HANDLER).timeBased().onWeekDay(ScriptApp.WeekDay.SUNDAY).atHour(7);
      break;
    case 'monthly':
      triggerBuilder = ScriptApp.newTrigger(SCHEDULED_TRIGGER_HANDLER).timeBased().onMonthDay(1).atHour(2);
      break;
    default:
      return { status: "Неверная частота" };
  }
  triggerBuilder.create();
  SCRIPT_PROPERTIES.setProperty('scheduleFrequency', frequency);
  return getScheduledTriggerStatus();
}

function deleteScheduledTrigger() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === SCHEDULED_TRIGGER_HANDLER) ScriptApp.deleteTrigger(t);
  });
  SCRIPT_PROPERTIES.deleteProperty('scheduleFrequency');
  return getScheduledTriggerStatus();
}

function getScheduledTriggerStatus() {
  const triggers = ScriptApp.getProjectTriggers();
  const trigger = triggers.find(t => t.getHandlerFunction() === SCHEDULED_TRIGGER_HANDLER);
  if (trigger) {
    const freq = SCRIPT_PROPERTIES.getProperty('scheduleFrequency');
    if (freq === 'weekly') return { status: "Еженедельно (ночь ВС)" };
    if (freq === 'weekly-morning') return { status: "Еженедельно (ВС 07:00)" };
    if (freq === 'monthly') return { status: "Ежемесячно (1-го числа)" };
    return { status: "Запланировано (неизвестно)" };
  }
  return { status: "Отключено" };
}

function runScheduledFullUpdate() {
  if (getUpdateStatus().isUpdating) {
    console.log("Плановое обновление пропущено, т.к. уже идет другой процесс.");
    return;
  }
  startUpdateProcess(null, SCRIPT_PROPERTIES.getProperty('searchQuery') || 'ветеринарные клиники и зоомагазины');
}

// === ДАШБОРД ===
function updateDashboard_() {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const sheet = ss.getSheetByName(DASHBOARD_SHEET_NAME);
    if (!sheet) return;

    const props = SCRIPT_PROPERTIES.getProperties();
    const lastUpdate = new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' });
    const duration = ((Date.now() - parseInt(props.startTime, 10)) / 60000).toFixed(1) + ' мин';
    
    sheet.getRange('B2').setValue(lastUpdate);
    sheet.getRange('B3').setValue(duration);
    sheet.getRange('B4').setValue(parseInt(props.totalNew || 0, 10));
    sheet.getRange('B5').setValue(parseInt(props.totalUpdated || 0, 10));
    sheet.getRange('B6').setValue(parseInt(props.totalClosed || 0, 10));
    sheet.getRange('B7').setValue(parseInt(props.totalSettlementsProcessed || 0, 10));
    
    // Принудительно обновляем формулы, которые могут зависеть от новых данных
    SpreadsheetApp.flush();
}