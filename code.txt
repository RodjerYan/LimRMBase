
// ===================================================================================
// Code.gs – Серверная логика
// Версия: 28.0 – Динамическое сопоставление колонок
// ===================================================================================

// --- КОНФИГУРАЦИЯ ---
const SHEET_ID = '13HkruBN9a_Y5xF8nUGpoyo3N7nJxiTW3PPgqw8FsApI';
const SHEET_NAME = 'Base';
const DASHBOARD_SHEET_NAME = 'Сводка';
const ALL_REGIONS_LIST = ["Москва", "Московская область", "Санкт-Петербург", "Ленинградская область", "Республика Адыгея", "Республика Алтай", "Республика Башкортостан", "Республика Бурятия", "Республика Дагестан", "Республика Ингушетия", "Кабардино-Балкарская Республика", "Республика Калмыкия", "Карачаво-Черкесская Республика", "Республика Карелия", "Республика Коми", "Республика Крым", "Республика Марий Эл", "Республика Мордовия", "Республика Саха (Якутия)", "Республика Северная Осетия — Алания", "Республика Татарстан", "Республика Тыва", "Удмуртская Республика", "Республика Хакасия", "Чеченская Республика", "Чувашская Республика", "Алтайский край", "Забайкальский край", "Камчатский край", "Краснодарский край", "Красноярский край", "Пермский край", "Приморский край", "Ставропольский край", "Хабаровский край", "Амурская область", "Архангельская область", "Астраханская область", "Белгородская область", "Брянская область", "Владимирская область", "Волгоградская область", "Вологодская область", "Воронежская область", "Ивановская область", "Иркутская область", "Калининградская область", "Калужская область", "Кемеровская область", "Кировская область", "Костромская область", "Курганская область", "Курская область", "Липецкая область", "Магаданская область", "Мурманская область", "Нижегородская область", "Новгородская область", "Новосибирская область", "Омская область", "Оренбургская область", "Орловская область", "Пензенская область", "Псковская область", "Ростовская область", "Рязанская область", "Самарская область", "Саратовская область", "Сахалинская область", "Свердловская область", "Смоленская область", "Тамбовская область", "Тверская область", "Томская область", "Тульская область", "Тюменская область", "Ульяновская область", "Челябинская область", "Ярославская область", "Севастополь", "Еврейская автономная область", "Ненецкий автономный округ", "Ханты-Мансийский автономный округ — Югра", "Чукотский автономный округ", "Ямало-Ненецкий автономный округ","Донецкая Народная Республика","Луганская Народная Республика","Запорожская область","Херсонская область","Харьковская область"];
const CACHE_EXPIRATION_SECONDS = 86400; // 24 часа
const SCRIPT_PROPERTIES = PropertiesService.getScriptProperties();
const USER_PROPERTIES = PropertiesService.getUserProperties();
const SCRIPT_CACHE = CacheService.getScriptCache();
const SCHEDULED_TRIGGER_HANDLER = 'runScheduledFullUpdate';
const OSM_CACHE_EXPIRATION = 86400; // 24 часа
const GEOAPIFY_API_KEY = 'd05c1c5c8bf447158d04cc3f49dee5fe';
const REGION_NAME_MAP_TO_OSM = {
  "Донецкая область": "Донецкая Народная Республика",
  "Луганская область": "Луганская Народная Республика"
};
const CITY_TO_REGION_MAP = {
  // === КАЛИНИНГРАДСКАЯ ОБЛАСТЬ ===
  'калининград': 'Калининградская область',
  'гвардейск': 'Калининградская область',
  'светлый': 'Калининградская область',
  'зеленоградск': 'Калининградская область',
  'гурьевск': 'Калининградская область',
  'пионерский': 'Калининградская область',
  'советск': 'Калининградская область',
  'светлогорск': 'Калининградская область',
  'багратионовск': 'Калининградская область',
  'черняховск': 'Калининградская область',
  'балтийск': 'Калининградская область',

  // === САНКТ-ПЕТЕРБУРГ + ЛЕНИНГРАДСКАЯ ОБЛАСТЬ ===
  'санкт-петербург': 'Санкт-Петербург',
  'кудрово': 'Ленинградская область',
  'мурино': 'Ленинградская область',
  'всеволожск': 'Ленинградская область',
  'выборг': 'Ленинградская область',
  'гатчина': 'Ленинградская область',
  'ломоносов': 'Санкт-Петербург',
  'сосновый бор': 'Ленинградская область',
  'кировск': 'Ленинградская область',
  'тосно': 'Ленинградская область',
  'колпино': 'Санкт-Петербург',
  'пушкин': 'Санкт-Петербург',
  'петергоф': 'Санкт-Петербург',
  'сестрорецк': 'Санкт-Петербург',
  'кронштадт': 'Санкт-Петербург',
  'коммунар': 'Ленинградская область',
  'тихвин': 'Ленинградская область',
  'сланцы': 'Ленинградская область',
  'приозерск': 'Ленинградская область',
  'волхов': 'Ленинградская область',

  // === НОВГОРОДСКАЯ ОБЛАСТЬ ===
  'великий новгород': 'Новгородская область',

  // === РАНЕЕ ДОБАВЛЕННЫЕ (ДНР, Запорожье) ===
  'енакиево': 'Донецкая Народная Республика',
  'шахтерск': 'Донецкая Народная Республика',
  'торез': 'Донецкая Народная Республика',
  'снежное': 'Донецкая Народная Республика',
  'харцызск': 'Донецкая Народная Республика',
  'мелитополь': 'Запорожская область',
  'бердянск': 'Запорожская область',
  'геническ': 'Запорожская область'
};
const EMERGENCY_STOP_FLAG = 'emergencyStopFlag'; // Флаг для надёжной остановки
let GEOAPIFY_LAST_CALL_TIMESTAMP = 0; // Для ограничителя скорости

// ===================================================================================
// === ГЛАВНАЯ ФУНКЦИЯ ДЛЯ WEB-ИНТЕРФЕЙСА ===
function doGet() {
  return HtmlService.createTemplateFromFile('index')
    .evaluate()
    .setTitle('Панель Управления Базой')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// ===================================================================================
// === ФУНКЦИИ УПРАВЛЕНИЯ ПРОЦЕССОМ ===
function startUpdateProcess(region, searchQuery) {
  if (getUpdateStatus().isUpdating) return { status: 'error', message: 'Процесс обновления уже запущен.' };
  
  SCRIPT_PROPERTIES.deleteProperty(EMERGENCY_STOP_FLAG);
  clearProcessProperties_();
  addLogEntry_('Инициализация нового процесса...', 'info');

  let regionsToProcess;
  let settlementsOverride = null;
  const isFullUpdate = !(region && region.trim());
  const now = new Date().getTime().toString();
  const searchFor = searchQuery || 'ветеринарные клиники и зоомагазины';

  if (isFullUpdate) {
    regionsToProcess = ALL_REGIONS_LIST;
  } else {
    const trimmedRegion = region.trim();
    const isKnownRegion = ALL_REGIONS_LIST.some(r => r.toLowerCase() === trimmedRegion.toLowerCase());
    if (isKnownRegion) {
      regionsToProcess = [trimmedRegion]; // Это известный регион
    } else {
      // Это, скорее всего, город. Создаём "виртуальный" регион для него.
      regionsToProcess = [`Поиск: "${trimmedRegion}"`];
      settlementsOverride = JSON.stringify([trimmedRegion]);
    }
  }

  const propertiesToSet = {
    'isUpdating': 'true', 'totalObjectsFoundOverall': '0',
    'regionsToProcess': JSON.stringify(regionsToProcess), 'searchQuery': searchFor,
    'startTime': now, 'isFullUpdate': isFullUpdate.toString(),
    'currentRegionIndex': '0', 'currentSettlementIndex': '0', 'settlementsForCurrentRegion': '[]',
    'totalSettlementsProcessed': '0', 'lastHeartbeat': now, 'consecutiveErrors': '0',
    'totalNew': '0', 'totalUpdated': '0', 'totalClosed': '0',
    'lastSpeedCheck': now, 'citiesPerMinute': '0'
  };

  if (settlementsOverride) {
    propertiesToSet.settlementsOverride = settlementsOverride;
  }

  SCRIPT_PROPERTIES.setProperties(propertiesToSet);

  USER_PROPERTIES.setProperties({ 'lastRegion': region, 'lastQuery': searchQuery });

  deleteProcessTriggers_();
  ScriptApp.newTrigger('mainProcessManager').timeBased().after(1000).create();
  return { status: 'success', message: 'Процесс запущен.' };
}

function continueUpdateProcess(region) {
  if (getUpdateStatus().isUpdating) return { status: 'error', message: 'Процесс обновления уже запущен.' };
  const props = SCRIPT_PROPERTIES.getProperties();
  if (!props.currentRegionIndex || props.finalSummary) return { status: 'error', message: 'Нет сохраненного состояния для продолжения.' };

  const errorCount = parseInt(props.consecutiveErrors || '0');
  if (errorCount > 0) {
    try {
        const emailAddress = 'rodjeryan@gmail.com';
        const subject = 'Уведомление: Возобновление обновления базы';
        const regions = JSON.parse(props.regionsToProcess || '[]');
        const regionIndex = parseInt(props.currentRegionIndex || '0');
        const lastRegion = regions[regionIndex] || 'Неизвестный регион';
        
        const body = `Здравствуйте,\n\nАвтоматическое обновление базы данных было возобновлено после паузы, вызванной ошибкой.\n\n` +
                     `Последний обрабатываемый регион: ${lastRegion}\n` +
                     `Количество ошибок перед паузой: ${errorCount}\n\n` +
                     `Процесс продолжается в штатном режиме.`;
        
        GmailApp.sendEmail(emailAddress, subject, body);
        addLogEntry_(`Отправлено email-уведомление о возобновлении после ошибки на ${emailAddress}`, 'info');
    } catch (e) {
        addLogEntry_(`Не удалось отправить email-уведомление: ${e.message}`, 'error');
    }
  }

  SCRIPT_PROPERTIES.deleteProperty(EMERGENCY_STOP_FLAG);
  
  if (region && region.trim()) {
    const newTarget = region.trim();
    addLogEntry_(`Перенаправление процесса на новую цель: "${newTarget}"...`, 'info');
    
    const originalRegions = ALL_REGIONS_LIST; // ALWAYS use the full list for redirection
    const startIndex = originalRegions.findIndex(r => r.toLowerCase() === newTarget.toLowerCase());

    if (startIndex !== -1) {
      const newRegionsToProcess = originalRegions.slice(startIndex);
      SCRIPT_PROPERTIES.setProperties({
        'regionsToProcess': JSON.stringify(newRegionsToProcess),
        'currentRegionIndex': '0',
        'currentSettlementIndex': '0',
        'settlementsForCurrentRegion': '[]',
        'isFullUpdate': 'true'
      });
      SCRIPT_PROPERTIES.deleteProperty('settlementsOverride');
      addLogEntry_(`Процесс продолжен с региона "${newTarget}" и далее по списку.`, 'success');
    } else {
      addLogEntry_(`Регион "${newTarget}" не найден в плане. Будет выполнен отдельный поиск только по этой цели.`, 'warning');
      const regionsToProcess = [`Поиск: "${newTarget}"`];
      const settlementsOverride = JSON.stringify([newTarget]);
      SCRIPT_PROPERTIES.setProperties({
        'regionsToProcess': JSON.stringify(regionsToProcess),
        'currentRegionIndex': '0',
        'currentSettlementIndex': '0',
        'settlementsForCurrentRegion': '[]',
        'isFullUpdate': 'false'
      });
      SCRIPT_PROPERTIES.setProperty('settlementsOverride', settlementsOverride);
    }
  }

  SCRIPT_PROPERTIES.setProperties({
    'isUpdating': 'true',
    'consecutiveErrors': '0'
  });
  SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
  SCRIPT_PROPERTIES.setProperty('lastHeartbeat', new Date().getTime().toString());

  deleteProcessTriggers_();
  ScriptApp.newTrigger('mainProcessManager').timeBased().after(1000).create();
  return { status: 'success', message: 'Процесс перенаправлен и возобновлён.' };
}


function cancelUpdateProcess() {
  SCRIPT_PROPERTIES.setProperty('cancelRequested', 'true');
  return { status: 'success', message: 'Запрос на остановку отправлен.' };
}

function stopAllProcesses() {
  addLogEntry_('Аварийная остановка инициирована...', 'error');
  
  ScriptApp.getProjectTriggers().forEach(t => ScriptApp.deleteTrigger(t));
  
  SCRIPT_PROPERTIES.setProperty(EMERGENCY_STOP_FLAG, 'true');

  SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
  SCRIPT_PROPERTIES.setProperty('progressMessage', 'Аварийная остановка. Процесс сброшен.');
  
  addLogEntry_('Все триггеры удалены. Процесс будет полностью остановлен после завершения текущей операции.', 'warning');
}

// ===================================================================================
// === МЕНЕДЖЕР ПРОЦЕССА ===
function mainProcessManager() {
  if (SCRIPT_PROPERTIES.getProperty(EMERGENCY_STOP_FLAG) === 'true') {
    SCRIPT_PROPERTIES.deleteProperty(EMERGENCY_STOP_FLAG);
    return;
  }

  const lock = LockService.getScriptLock();
  if (!lock.tryLock(60000)) { createContinuationTrigger_('mainProcessManager', 5000); return; }

  try {
    let props = SCRIPT_PROPERTIES.getProperties();
    if (props.isUpdating !== 'true') { deleteProcessTriggers_(); return; }
    if (props.cancelRequested === 'true') {
      addLogEntry_('Процесс остановлен пользователем.', 'warning');
      SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
      SCRIPT_PROPERTIES.setProperty('progressMessage', 'Пауза. Нажмите "Продолжить".');
      SCRIPT_PROPERTIES.deleteProperty('cancelRequested');
      deleteProcessTriggers_();
      return;
    }

    SCRIPT_PROPERTIES.setProperty('lastHeartbeat', new Date().getTime().toString());

    const regions = JSON.parse(props.regionsToProcess);
    let regionIndex = parseInt(props.currentRegionIndex || '0');
    let settlementIndex = parseInt(props.currentSettlementIndex || '0');
    let settlements = JSON.parse(props.settlementsForCurrentRegion || '[]');

    updateProgressMessage_(regions, regionIndex, settlementIndex, settlements, props);

    if (settlementIndex >= settlements.length) {
      if (regionIndex > 0 && settlements.length > 0) {
         addLogEntry_(`✅ Регион "${regions[regionIndex-1]}" полностью обработан.`, 'success');
      }
      if (regionIndex >= regions.length) {
        if (props.isFullUpdate === 'true') finalizeSmartUpdate_();
        resetState_('Обновление успешно завершено.', parseInt(props.totalSettlementsProcessed || '0'), parseInt(props.totalObjectsFoundOverall || '0'));
        return;
      }
      const currentRegion = regions[regionIndex];
      addLogEntry_(`--- Обработка нового региона: ${currentRegion} (${regionIndex + 1}/${regions.length}) ---`, 'success');

      const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
      const isFullRun = props.isFullUpdate === 'true';
      const isFreshStartOfProcess = regionIndex === 0;

      if (isFullRun) {
        const isFreshFullUpdate = regions.length === ALL_REGIONS_LIST.length;
        if (isFreshFullUpdate) {
          if (isFreshStartOfProcess) {
            prepareForSmartUpdate_(sheet, 'full', null);
          }
        } else {
          prepareForSmartUpdate_(sheet, detectRegionType_(currentRegion), currentRegion);
        }
      } else {
        prepareForSmartUpdate_(sheet, detectRegionType_(currentRegion), currentRegion);
      }

      let newSettlements;
      if (props.settlementsOverride) {
        newSettlements = JSON.parse(props.settlementsOverride);
        SCRIPT_PROPERTIES.deleteProperty('settlementsOverride');
      } else {
        newSettlements = getSettlementsForRegion_(currentRegion) || [];
      }

      if (newSettlements.length === 0) {
        addLogEntry_(`В "${currentRegion}" не найдено НП. Пропускаем.`, 'warning');
        SCRIPT_PROPERTIES.setProperty('currentRegionIndex', (regionIndex + 1).toString());
        createContinuationTrigger_('mainProcessManager', 1000);
        return;
      }

      SCRIPT_PROPERTIES.setProperties({
        'settlementsForCurrentRegion': JSON.stringify(newSettlements),
        'currentSettlementIndex': '0'
      });
      createContinuationTrigger_('mainProcessManager', 1000);
      return;
    }

    const settlementName = settlements[settlementIndex];
    const regionName = regions[regionIndex];
    
    const result = searchByOSM_(settlementName, regionName);
    
    let newCnt = 0, updCnt = 0, closedCnt = 0;
    if (result && result.status === 'success' && result.data && result.data.length > 0) {
      const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
      try {
        const stats = smartUpdateSheet_(sheet, result.data, settlementName);
        newCnt = stats.new; updCnt = stats.updated; closedCnt = stats.closed;
        addLogEntry_(`→ ${settlementName}: +${newCnt} новых, ${updCnt} обновлено, ${closedCnt} закрыто`, 'success');
      } catch (e) {
        addLogEntry_(`ОШИБКА ЗАПИСИ в "${settlementName}": ${e.message}`, 'error');
      }
    } else {
      addLogEntry_(`→ ${settlementName}: ничего не найдено`, 'info');
    }

    const totalNew = parseInt(props.totalNew || '0') + newCnt;
    const totalUpd = parseInt(props.totalUpdated || '0') + updCnt;
    const totalClosed = parseInt(props.totalClosed || '0') + closedCnt;
    SCRIPT_PROPERTIES.setProperties({
      'totalNew': totalNew.toString(),
      'totalUpdated': totalUpd.toString(),
      'totalClosed': totalClosed.toString()
    });

    SCRIPT_PROPERTIES.setProperty('currentSettlementIndex', (settlementIndex + 1).toString());
    if (settlementIndex + 1 >= settlements.length) {
      const total = parseInt(props.totalSettlementsProcessed || '0') + settlements.length;
      SCRIPT_PROPERTIES.setProperty('totalSettlementsProcessed', total.toString());
      SCRIPT_PROPERTIES.setProperty('currentRegionIndex', (regionIndex + 1).toString());
    }
    SCRIPT_PROPERTIES.setProperty('consecutiveErrors', '0');
    
    if (SCRIPT_PROPERTIES.getProperty(EMERGENCY_STOP_FLAG) === 'true') {
      SCRIPT_PROPERTIES.deleteProperty(EMERGENCY_STOP_FLAG); 
      addLogEntry_('Аварийная остановка подтверждена. Цепочка триггеров прервана.', 'warning');
      return;
    }
    createContinuationTrigger_('mainProcessManager', 3000);

  } catch (e) {
    addLogEntry_(`КРИТИЧЕСКАЯ ОШИБОКА: ${e.message}\n${e.stack}`, 'error');
    const errors = parseInt(SCRIPT_PROPERTIES.getProperty('consecutiveErrors') || '0') + 1;
    SCRIPT_PROPERTIES.setProperty('consecutiveErrors', errors.toString());
    if (errors >= 3) {
      try { GmailApp.sendEmail(Session.getEffectiveUser().getEmail(), 'Критическая ошибка в скрипте обновления базы', e.stack); } catch {}
    }
    SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
    deleteProcessTriggers_();
  } finally { lock.releaseLock(); }
}

// === ПОДРОБНЫЙ ПРОГРЕСС ===========================================================
function updateProgressMessage_(regions, ri, si, settlements, props) {
  if (!regions || !settlements) return; 
  const totalSett = settlements.length;
  const regionProg = `${ri + 1}/${regions.length}`;
  const cityProg = totalSett > 0 ? `${si + 1}/${totalSett}` : '0/0';
  const processedCities = parseInt(props.totalSettlementsProcessed || '0') + si;

  const now = Date.now();
  const lastCheck = parseInt(props.lastSpeedCheck || now);
  let speed = props.citiesPerMinute || '0';
  if (now - lastCheck > 20000) { 
    const elapsedMin = (now - parseInt(props.startTime)) / 60000;
    if (elapsedMin > 0.5) { 
      speed = (processedCities / elapsedMin).toFixed(1);
      SCRIPT_PROPERTIES.setProperties({ 'lastSpeedCheck': now.toString(), 'citiesPerMinute': speed });
    }
  }

  const regionName = regions[ri] || '...';
  const settlName = settlements[si] || '...';

  const progressMessage = `Регион: ${regionName} [${regionProg}] | НП: ${settlName} [${cityProg}]`;
  
  const totalRegions = regions.length;
  const regionWeight = 1 / totalRegions;
  const settlementProgress = totalSett > 0 ? si / totalSett : 1;
  const totalProgress = ((ri + settlementProgress) * regionWeight) * 100;
  
  SCRIPT_PROPERTIES.setProperties({ 
    'progressMessage': progressMessage,
    'totalProgress': Math.floor(totalProgress).toString()
  });
}

// ===================================================================================
// === РАБОТА С OpenStreetMap И ГЕОКОДЕРАМИ ===
function searchByOSM_(settlementName, regionName) {
  const osmRegionName = REGION_NAME_MAP_TO_OSM[regionName] || regionName;
  addLogEntry_(`Поиск OSM для "${settlementName}" в регионе "${regionName}" (OSM: ${osmRegionName})`, 'info');
  const cacheKey = `osm_v5_${osmRegionName}_${settlementName}_vet_pet_shops`;
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) {
    addLogEntry_('Данные OSM взяты из кэша.', 'info');
    return JSON.parse(cached);
  }

  const overpassUrl = 'https://overpass-api.de/api/interpreter';
  const query = `
    [out:json][timeout:180];
    area["name"="${osmRegionName}"]["admin_level"~"2|4"]->.regionArea;
    area["name"="${settlementName}"]["place"~"city|town"](area.regionArea)->.cityArea;
    (
      nwr["amenity"="veterinary"](area.cityArea);
      nwr["shop"="pet"](area.cityArea);
    );
    out center;
  `.trim();

  const options = {
    'method': 'post',
    'contentType': 'application/x-www-form-urlencoded',
    'payload': { 'data': query },
    'muteHttpExceptions': true
  };
  
  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      const response = UrlFetchApp.fetch(overpassUrl, options);
      const responseCode = response.getResponseCode();
      if (responseCode === 200) {
        const data = JSON.parse(response.getContentText());
        let elements = data.elements;

        const limit = 50;
        if (elements.length > limit) {
          addLogEntry_(`Найдено ${elements.length} объектов, обрабатываем первые ${limit} для стабильности.`, 'warning');
          elements = elements.slice(0, limit);
        }

        const formattedData = elements.map(el => {
          const tags = el.tags || {};
          const coords = el.center ? { lat: el.center.lat, lon: el.center.lon } : { lat: el.lat, lon: el.lon };
          
          let category = 'Не определена';
          if (tags.amenity === 'veterinary') {
            category = 'Ветеринарная клиника';
          } else if (tags.shop === 'pet') {
            category = 'Зоомагазин';
          }
          
          let address = buildAddressFromTags_(tags);
          if (address.startsWith('Координаты:')) {
             const geoapifyAddress = getAddressFromGeoapify_(coords.lat, coords.lon);
             if (geoapifyAddress) {
               address = geoapifyAddress;
             } else {
               address = `Координаты: ${coords.lat.toFixed(5)}, ${coords.lon.toFixed(5)}`;
             }
          }

          const realRegion = findRegionForCity_(settlementName);

          return {
            id: `osm-${el.id}`,
            name: tags.name || 'Без названия',
            category: category,
            address: address,
            phone: tags.phone || tags['contact:phone'] || '',
            lat: coords.lat,
            lon: coords.lon,
            source: 'OSM',
            city: settlementName,
            region: realRegion || regionName
          };
        });
        
        const result = { status: 'success', data: formattedData };
        SCRIPT_CACHE.put(cacheKey, JSON.stringify(result), OSM_CACHE_EXPIRATION);
        return result;

      } else {
        addLogEntry_(`Overpass ошибка (попытка ${attempt}/3): HTTP ${responseCode}`, 'error');
        if (attempt < 3) Utilities.sleep(15000 * attempt);
      }
    } catch (e) {
      addLogEntry_(`Overpass ошибка сети (попытка ${attempt}/3): ${e.message}`, 'error');
      if (attempt < 3) Utilities.sleep(15000 * attempt);
    }
  }
  return { status: 'error', message: 'Не удалось получить данные от Overpass API после 3 попыток.' };
}

function buildAddressFromTags_(tags) {
  const addressParts = [];
  const city = tags['addr:city'] || tags['addr:place'] || tags['addr:settlement'];
  const street = tags['addr:street'];
  const houseNumber = tags['addr:housenumber'];
  
  if (city) addressParts.push(city);
  if (street) addressParts.push(street);
  if (houseNumber) {
    const prefix = street ? (houseNumber.match(/[а-яА-Я]/) ? '' : 'д. ') : '';
    addressParts.push(`${prefix}${houseNumber}`);
  }
  
  if (street && houseNumber) {
    return addressParts.join(', ');
  }
  
  return 'Координаты:'; 
}

function getAddressFromGeoapify_(lat, lon) {
  const cacheKey = `geoapify_${lat.toFixed(5)}_${lon.toFixed(5)}`;
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) {
    return cached;
  }

  const now = Date.now();
  const timeSinceLastCall = now - GEOAPIFY_LAST_CALL_TIMESTAMP;
  if (timeSinceLastCall < 1100) {
    Utilities.sleep(1100 - timeSinceLastCall);
  }
  GEOAPIFY_LAST_CALL_TIMESTAMP = Date.now();

  try {
    const url = `https://api.geoapify.com/v1/geocode/reverse?lat=${lat}&lon=${lon}&apiKey=${GEOAPIFY_API_KEY}&lang=ru`;
    const response = UrlFetchApp.fetch(url, { 'muteHttpExceptions': true });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      const address = data.features[0]?.properties?.formatted;
      if (address) {
        SCRIPT_CACHE.put(cacheKey, address, CACHE_EXPIRATION_SECONDS);
        return address;
      }
    }
    return null;
  } catch (e) {
    return null;
  }
}

function getSettlementsForRegion_(region) {
  const osmRegionName = REGION_NAME_MAP_TO_OSM[region] || region;
  const cacheKey = `settlements_v7_universal_${osmRegionName}`;
  const cached = SCRIPT_CACHE.get(cacheKey);
  if (cached) return JSON.parse(cached);

  addLogEntry_(`Запрос списка городов и посёлков для "${region}" (используется имя OSM: "${osmRegionName}")...`, 'info');
  const overpassUrl = 'https://overpass-api.de/api/interpreter';
  const query = `
    [out:json][timeout:120];
    (
      area[name="${osmRegionName}"]["admin_level"~"2|4"];
    )->.searchArea;
    (
      node["place"~"city|town"](area.searchArea);
    );
    out body;
  `.trim();
  
  const options = {
    'method': 'post',
    'payload': { 'data': query },
    'muteHttpExceptions': true
  };

  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      const response = UrlFetchApp.fetch(overpassUrl, options);
      const responseCode = response.getResponseCode();
      if (responseCode === 200) {
        const data = JSON.parse(response.getContentText());
        
        let capital = null;
        const otherSettlements = [];

        data.elements.forEach(el => {
          if (el.tags && el.tags.capital && el.tags.name) {
            capital = el.tags.name;
          } else if (el.tags && el.tags.name) {
            otherSettlements.push(el.tags.name);
          }
        });
        
        const uniqueOthers = [...new Set(otherSettlements.filter(name => name !== capital))]
          .sort((a, b) => a.localeCompare(b, 'ru'));
        
        const settlements = [];
        if (capital) {
          settlements.push(capital);
          addLogEntry_(`Столица региона "${capital}" будет обработана первой.`, 'info');
        }
        settlements.push(...uniqueOthers);

        addLogEntry_(`Список НП для "${region}" получен (${settlements.length} шт). Начинаем обработку...`, 'info');
        SCRIPT_CACHE.put(cacheKey, JSON.stringify(settlements), CACHE_EXPIRATION_SECONDS);
        return settlements;
      } else {
        addLogEntry_(`Ошибка получения списка НП для "${region}" (попытка ${attempt}/3): HTTP ${responseCode}`, 'error');
        if (attempt < 3) Utilities.sleep(10000 * attempt);
      }
    } catch (e) {
      addLogEntry_(`Ошибка сети при получении списка НП для "${region}" (попытка ${attempt}/3): ${e.message}`, 'error');
      if (attempt < 3) Utilities.sleep(10000 * attempt);
    }
  }

  addLogEntry_(`Не удалось получить список НП для "${region}" после 3 попыток.`, 'error');
  return [];
}


// ===================================================================================
// === РАБОТА С GOOGLE ТАБЛИЦЕЙ (SMART UPDATE V2) ===

function smartUpdateSheet_(sheet, newData, currentCity) {
  if (!newData || newData.length === 0) return { new: 0, updated: 0, closed: 0 };

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const colMap = headers.reduce((acc, header, i) => { acc[header] = i; return acc; }, {});

  const essentialCols = ['ID OSM', 'Город', 'Статус'];
  for (const col of essentialCols) {
    if (colMap[col] === undefined) throw new Error(`В таблице отсутствует обязательный столбец "${col}".`);
  }

  const allData = sheet.getDataRange().getValues().slice(1);

  const existingCityData = allData.filter(row => row[colMap['Город']] === currentCity);
  const existingIds = new Set(existingCityData.map(row => row[colMap['ID OSM']]));

  const toAddRows = [];
  const toUpdateRequests = [];
  const now = new Date();

  newData.forEach(newItem => {
    if (existingIds.has(newItem.id)) {
      const rowIndex = allData.findIndex(row => row[colMap['ID OSM']] === newItem.id);
      if (rowIndex !== -1 && allData[rowIndex][colMap['Статус']] === 'marked_for_update') {
        const rowNum = rowIndex + 2;
        if (colMap['Наименование'] !== undefined) toUpdateRequests.push({ range: `${SHEET_NAME}!${String.fromCharCode(65 + colMap['Наименование'])}${rowNum}`, values: [[newItem.name]] });
        if (colMap['Категория'] !== undefined) toUpdateRequests.push({ range: `${SHEET_NAME}!${String.fromCharCode(65 + colMap['Категория'])}${rowNum}`, values: [[newItem.category]] });
        if (colMap['Адрес'] !== undefined) toUpdateRequests.push({ range: `${SHEET_NAME}!${String.fromCharCode(65 + colMap['Адрес'])}${rowNum}`, values: [[newItem.address]] });
        if (colMap['Контакты'] !== undefined) toUpdateRequests.push({ range: `${SHEET_NAME}!${String.fromCharCode(65 + colMap['Контакты'])}${rowNum}`, values: [[newItem.phone || '']] });
        if (colMap['Дата обновления'] !== undefined) toUpdateRequests.push({ range: `${SHEET_NAME}!${String.fromCharCode(65 + colMap['Дата обновления'])}${rowNum}`, values: [[now]] });
        if (colMap['Статус'] !== undefined) toUpdateRequests.push({ range: `${SHEET_NAME}!${String.fromCharCode(65 + colMap['Статус'])}${rowNum}`, values: [['active']] });
      }
    } else {
      const newRow = new Array(headers.length).fill('');
      if (colMap['ID OSM'] !== undefined) newRow[colMap['ID OSM']] = newItem.id;
      if (colMap['Страна'] !== undefined) newRow[colMap['Страна']] = 'Россия';
      if (colMap['Субъект'] !== undefined) newRow[colMap['Субъект']] = newItem.region;
      if (colMap['Город'] !== undefined) newRow[colMap['Город']] = newItem.city;
      if (colMap['Категория'] !== undefined) newRow[colMap['Категория']] = newItem.category;
      if (colMap['Наименование'] !== undefined) newRow[colMap['Наименование']] = newItem.name;
      if (colMap['Адрес'] !== undefined) newRow[colMap['Адрес']] = newItem.address;
      if (colMap['Контакты'] !== undefined) newRow[colMap['Контакты']] = newItem.phone || '';
      if (colMap['Дата обновления'] !== undefined) newRow[colMap['Дата обновления']] = now;
      if (colMap['Дата добавления'] !== undefined) newRow[colMap['Дата добавления']] = now;
      if (colMap['Статус'] !== undefined) newRow[colMap['Статус']] = 'active';
      if (colMap['Источник'] !== undefined) newRow[colMap['Источник']] = 'OSM';
      if (colMap['lat'] !== undefined) newRow[colMap['lat']] = newItem.lat;
      if (colMap['lon'] !== undefined) newRow[colMap['lon']] = newItem.lon;
      toAddRows.push(newRow);
    }
  });

  if (toAddRows.length > 0) {
    sheet.getRange(sheet.getLastRow() + 1, 1, toAddRows.length, headers.length).setValues(toAddRows);
  }
  
  if (toUpdateRequests.length > 0) {
    Sheets.Spreadsheets.Values.batchUpdate({ data: toUpdateRequests, valueInputOption: "USER_ENTERED" }, SHEET_ID);
  }

  const activeIdsInNewData = new Set(newData.map(item => item.id));
  const closedCount = existingCityData.filter(row =>
    row[colMap['ID OSM']]?.toString().startsWith('osm-') &&
    !activeIdsInNewData.has(row[colMap['ID OSM']]) &&
    row[colMap['Статус']] !== 'closed'
  ).length;
  
  const updatedCount = new Set(toUpdateRequests.map(r => r.range.match(/\d+/)[0])).size;

  return { new: toAddRows.length, updated: updatedCount, closed: closedCount };
}

function prepareForSmartUpdate_(sheet, type, region) {
  addLogEntry_(`Подготовка к обновлению для "${region || 'всей базы'}"...`, 'info');
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const colMap = headers.reduce((acc, h, i) => { acc[h] = i; return acc; }, {});

  if (colMap['Статус'] === undefined || colMap['Источник'] === undefined || colMap['Субъект'] === undefined || colMap['Город'] === undefined) {
    addLogEntry_('Пропуск маркировки: отсутствуют необходимые колонки (Статус, Источник, Субъект, Город).', 'warning');
    return;
  }
  const statusColIndex = colMap['Статус'];
  const statusColLetter = String.fromCharCode(65 + statusColIndex);

  const data = sheet.getDataRange().getValues().slice(1);
  const rangesToUpdate = [];
  data.forEach((row, index) => {
    const isOsmSource = row[colMap['Источник']] === 'OSM';
    const isActive = row[statusColIndex] === 'active';
    let shouldMark = false;

    if (type === 'full' && isOsmSource && isActive) shouldMark = true;
    else if (type === 'region' && isOsmSource && isActive && row[colMap['Субъект']] === region) shouldMark = true;
    else if (type === 'city' && isOsmSource && isActive && row[colMap['Город']] === region) shouldMark = true;
    
    if (shouldMark) {
      rangesToUpdate.push(`${SHEET_NAME}!${statusColLetter}${index + 2}`);
    }
  });

  if (rangesToUpdate.length > 0) {
    const requests = rangesToUpdate.map(range => ({ range, values: [['marked_for_update']] }));
    for (let i = 0; i < requests.length; i += 500) {
      Sheets.Spreadsheets.Values.batchUpdate({ data: requests.slice(i, i + 500), valueInputOption: "RAW" }, SHEET_ID);
    }
    addLogEntry_(`Помечено ${rangesToUpdate.length} записей для проверки.`, 'info');
  } else {
    addLogEntry_(`Нет активных записей OSM для проверки в "${region || 'базе'}".`, 'info');
  }
}

function finalizeSmartUpdate_() {
  addLogEntry_('Завершение "умного" обновления: закрытие устаревших записей...', 'info');
  const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
  const data = sheet.getDataRange().getValues();
  const headers = data.shift();
  const statusColIndex = headers.indexOf('Статус');
  if (statusColIndex === -1) {
    addLogEntry_('Пропуск финализации: отсутствует колонка "Статус".', 'error');
    return;
  }
  const statusColLetter = String.fromCharCode(65 + statusColIndex);
  
  const rangesToUpdate = [];
  data.forEach((row, index) => {
    if (row[statusColIndex] === 'marked_for_update') {
      rangesToUpdate.push(`${SHEET_NAME}!${statusColLetter}${index + 2}`);
    }
  });

  if (rangesToUpdate.length > 0) {
    const requests = rangesToUpdate.map(range => ({ range, values: [['closed']] }));
    for (let i = 0; i < requests.length; i += 500) {
      Sheets.Spreadsheets.Values.batchUpdate({ data: requests.slice(i, i + 500), valueInputOption: "RAW" }, SHEET_ID);
    }
    addLogEntry_(`${rangesToUpdate.length} устаревших записей было закрыто.`, 'success');
  } else {
    addLogEntry_('Не найдено устаревших записей для закрытия.', 'info');
  }
}

// ===================================================================================
// === ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ===
function findRegionForCity_(cityName) {
  if (!cityName) return null;
  const cityKey = cityName.toString().toLowerCase().trim();
  return CITY_TO_REGION_MAP[cityKey] || null;
}

function getUpdateStatus() {
  const props = SCRIPT_PROPERTIES.getProperties();
  const logs = getLogEntries_();
  const stats = {
    new: props.totalNew || '0',
    updated: props.totalUpdated || '0',
    closed: props.totalClosed || '0',
    speed: props.citiesPerMinute || '0'
  };
  return {
    isUpdating: props.isUpdating === 'true',
    canContinue: !!props.currentRegionIndex && props.isUpdating !== 'true' && !props.finalSummary,
    cancelRequested: props.cancelRequested === 'true',
    progressMessage: props.progressMessage || 'Ожидание...',
    totalProgress: props.totalProgress || '0',
    liveLog: logs,
    finalSummary: props.finalSummary ? JSON.parse(props.finalSummary) : null,
    stats: stats,
  };
}

function getSearchHistory() {
  return USER_PROPERTIES.getProperties();
}

function addLogEntry_(message, type) {
  const timestamp = new Date().toLocaleTimeString('ru-RU');
  const logEntry = `<p class="log-${type}">[${timestamp}] ${message}</p>`;
  let logs = SCRIPT_PROPERTIES.getProperty('liveLog') || '';
  const logLines = logs.split('</p>').filter(Boolean);
  if (logLines.length > 100) {
    logs = logLines.slice(logLines.length - 100).join('</p>') + '</p>';
  }
  SCRIPT_PROPERTIES.setProperty('liveLog', logs + logEntry);
}

function getLogEntries_() {
  return SCRIPT_PROPERTIES.getProperty('liveLog') || '';
}

function clearProcessProperties_() {
  const keys = SCRIPT_PROPERTIES.getKeys().filter(k => k !== 'scheduleFrequency');
  if (keys.length > 0) {
    keys.forEach(key => SCRIPT_PROPERTIES.deleteProperty(key));
  }
}

function deleteProcessTriggers_() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'mainProcessManager') {
      ScriptApp.deleteTrigger(t);
    }
  });
}

function createContinuationTrigger_(handler, delay) {
  deleteProcessTriggers_();
  ScriptApp.newTrigger(handler).timeBased().after(delay).create();
}

function resetState_(finalMessage, cities, objects) {
  deleteProcessTriggers_();
  const startTime = parseInt(SCRIPT_PROPERTIES.getProperty('startTime') || Date.now());
  const duration = ((Date.now() - startTime) / 60000).toFixed(1) + ' мин';
  const summary = {
    message: finalMessage, duration: duration, citiesProcessed: cities,
    totalObjectsFound: objects,
    sheetUrl: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/edit#gid=0`,
    dashboardUrl: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/edit#gid=${SpreadsheetApp.openById(SHEET_ID).getSheetByName(DASHBOARD_SHEET_NAME).getSheetId()}`
  };
  SCRIPT_PROPERTIES.setProperty('finalSummary', JSON.stringify(summary));
  SCRIPT_PROPERTIES.setProperty('isUpdating', 'false');
  addLogEntry_(`${finalMessage} Время выполнения: ${duration}.`, 'success');
  
  try { updateDashboard_(); } catch (e) { addLogEntry_(`Не удалось обновить дашборд: ${e.message}`, 'error');}
}

function detectRegionType_(regionName) {
  if (regionName.toLowerCase().includes('область') || regionName.toLowerCase().includes('край') || regionName.toLowerCase().includes('республика')) {
    return 'region';
  }
  return 'city';
}

// === ПЛАНИРОВЩИК ===
function createScheduledTrigger(frequency) {
  deleteScheduledTrigger();
  let triggerBuilder;
  switch (frequency) {
    case 'weekly':
      triggerBuilder = ScriptApp.newTrigger(SCHEDULED_TRIGGER_HANDLER).timeBased().onWeekDay(ScriptApp.WeekDay.SUNDAY).atHour(2);
      break;
    case 'weekly-morning':
      triggerBuilder = ScriptApp.newTrigger(SCHEDULED_TRIGGER_HANDLER).timeBased().onWeekDay(ScriptApp.WeekDay.SUNDAY).atHour(7);
      break;
    case 'monthly':
      triggerBuilder = ScriptApp.newTrigger(SCHEDULED_TRIGGER_HANDLER).timeBased().onMonthDay(1).atHour(2);
      break;
    default:
      return { status: "Неверная частота" };
  }
  triggerBuilder.create();
  SCRIPT_PROPERTIES.setProperty('scheduleFrequency', frequency);
  return getScheduledTriggerStatus();
}

function deleteScheduledTrigger() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === SCHEDULED_TRIGGER_HANDLER) ScriptApp.deleteTrigger(t);
  });
  SCRIPT_PROPERTIES.deleteProperty('scheduleFrequency');
  return getScheduledTriggerStatus();
}

function getScheduledTriggerStatus() {
  const triggers = ScriptApp.getProjectTriggers();
  const trigger = triggers.find(t => t.getHandlerFunction() === SCHEDULED_TRIGGER_HANDLER);
  if (trigger) {
    const freq = SCRIPT_PROPERTIES.getProperty('scheduleFrequency');
    if (freq === 'weekly') return { status: "Еженедельно (ночь ВС)" };
    if (freq === 'weekly-morning') return { status: "Еженедельно (ВС 07:00)" };
    if (freq === 'monthly') return { status: "Ежемесячно (1-го числа)" };
    return { status: "Запланировано (неизвестно)" };
  }
  return { status: "Отключено" };
}

function runScheduledFullUpdate() {
  if (getUpdateStatus().isUpdating) {
    console.log("Плановое обновление пропущено, т.к. уже идет другой процесс.");
    return;
  }
  startUpdateProcess(null, SCRIPT_PROPERTIES.getProperty('searchQuery') || 'ветеринарные клиники и зоомагазины');
}

// === ДАШБОРД ===
function updateDashboard_() {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const sheet = ss.getSheetByName(DASHBOARD_SHEET_NAME);
    if (!sheet) return;

    const props = SCRIPT_PROPERTIES.getProperties();
    const lastUpdate = new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' });
    const duration = ((Date.now() - parseInt(props.startTime, 10)) / 60000).toFixed(1) + ' мин';
    
    sheet.getRange('B2').setValue(lastUpdate);
    sheet.getRange('B3').setValue(duration);
    sheet.getRange('B4').setValue(parseInt(props.totalNew || 0, 10));
    sheet.getRange('B5').setValue(parseInt(props.totalUpdated || 0, 10));
    sheet.getRange('B6').setValue(parseInt(props.totalClosed || 0, 10));
    sheet.getRange('B7').setValue(parseInt(props.totalSettlementsProcessed || 0, 10));
    
    SpreadsheetApp.flush();
}